<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="SmartSplash™ Silicone Sink Splash Guard stops water from splashing onto your clothes and floors. Soft, flexible silicone with secure suction grip. Free UK shipping & 30-day guarantee. Only $24.99.">
    <meta name="keywords" content="sink splash guard, silicone splash guard, kitchen sink guard, water splash protector, sink water barrier">
    <meta name="author" content="SmartSplash">
    <meta property="og:title" content="SmartSplash™ - Stop the Splash, Save Your Shirt">
    <meta property="og:description" content="The flexible silicone sink splash guard that keeps your clothes dry and floors safe. Free shipping & 30-day guarantee.">
    <meta property="og:type" content="product">
    <meta property="og:image" content="smart-splash-hero.webp">
    <meta property="og:image:alt" content="SmartSplash Silicone Sink Splash Guard installed on a modern kitchen sink">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="SmartSplash™ - Stop the Splash, Save Your Shirt">
    <meta name="twitter:description" content="The flexible silicone sink splash guard that keeps your clothes dry. Free shipping & 30-day guarantee.">
    <meta name="twitter:image" content="smart-splash-hero.webp">
    <link rel="canonical" href="https://smartsplash.co.uk/">
    <title>SmartSplash™ Silicone Sink Splash Guard - Stop Wet Shirts & Floors</title>
    
    <!-- Structured Data: Product + AggregateRating -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Product",
        "name": "SmartSplash™ Silicone Sink Splash Guard",
        "description": "A flexible silicone sink splash guard with suction grip that blocks water splashes, keeping your clothes dry and floors safe.",
        "image": "smart-splash-hero.webp",
        "brand": {
            "@type": "Brand",
            "name": "SmartSplash"
        },
        "offers": {
            "@type": "Offer",
            "price": "24.99",
            "priceCurrency": "USD",
            "availability": "https://schema.org/InStock",
            "shippingDetails": {
                "@type": "OfferShippingDetails",
                "shippingRate": {
                    "@type": "MonetaryAmount",
                    "value": "0",
                    "currency": "USD"
                },
                "shippingDestination": {
                    "@type": "DefinedRegion",
                    "addressCountry": "GB"
                }
            }
        },
        "aggregateRating": {
            "@type": "AggregateRating",
            "ratingValue": "4.9",
            "ratingCount": "2431",
            "bestRating": "5",
            "worstRating": "1"
        }
    }
    </script>
    
    <!-- Structured Data: FAQPage -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [
            {
                "@type": "Question",
                "name": "Will this stick to my sink?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "SmartSplash™ adheres best to smooth, non-porous surfaces like granite, marble, quartz, polished wood, and stainless steel. It may struggle on rough, unsealed stone or heavily textured tiles because the suction cups need a flat surface to seal."
                }
            },
            {
                "@type": "Question",
                "name": "How do I clean it?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Rinse with warm soapy water after use or place it on the top rack of your dishwasher. The silicone is heat-resistant and built for daily use."
                }
            },
            {
                "@type": "Question",
                "name": "Does it get in the way of my arms?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "No. The soft, flexible silicone bends comfortably if your arms brush against it—unlike hard plastic guards that dig into your skin."
                }
            },
            {
                "@type": "Question",
                "name": "Will it mold or start to smell?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Silicone is naturally non-porous and resistant to mold and mildew. It doesn't absorb water or odors—just give it a quick rinse periodically."
                }
            },
            {
                "@type": "Question",
                "name": "What happens if I bump it?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "The suction cups hold firm against normal bumps. If you hit it hard, it flexes rather than cracks—simply press it back down if any suction releases."
                }
            },
            {
                "@type": "Question",
                "name": "Can I move it between sinks?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Yes! Peel up one edge to release the seal, move it to another sink, and press down again. Perfect for kitchen, laundry, or utility sinks."
                }
            },
            {
                "@type": "Question",
                "name": "Is it safe for kids and families?",
                "acceptedAnswer": {
                    "@type": "Answer",
                    "text": "Absolutely. The soft silicone has no sharp edges, making it safe for little helpers learning to wash dishes—and it reduces slippery floor puddles."
                }
            }
        ]
    }
    </script>
    
    <!-- Structured Data: BreadcrumbList for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [
            {
                "@type": "ListItem",
                "position": 1,
                "name": "Home",
                "item": "https://smartsplash.co.uk/"
            },
            {
                "@type": "ListItem",
                "position": 2,
                "name": "SmartSplash™ Silicone Sink Splash Guard",
                "item": "https://smartsplash.co.uk/smartsplash/"
            }
        ]
    }
    </script>
    
    <!-- Preload critical resources for faster LCP -->
    <link rel="preload" as="image" href="smart-splash-hero.webp" type="image/webp">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500;700&display=swap" rel="stylesheet">
    
    <!-- Preconnect to Shopify for faster checkout -->
    <link rel="preconnect" href="https://sdks.shopifycdn.com">
    <style>
        :root {
            --color-bg: #F0F4F8; /* "Cool Mist" - slightly darker to show particles */
            --color-surface: #FFFFFF;
            --color-text-main: #1D1D1F;
            --color-text-muted: #86868B;
            --color-accent: #0891B2; /* Sophisticated Deep Teal - "The Shade" */
            --color-accent-glow: rgba(8, 145, 178, 0.25);
            --color-dark: #151516;
            
            --font-heading: 'Space Grotesk', sans-serif;
            --font-body: 'Inter', sans-serif;
            
            /* Apple-style "smooth" easing */
            --ease-out-expo: cubic-bezier(0.165, 0.84, 0.44, 1);
            --container-width: 1200px;
            --header-height: 80px;
            
            /* Consistent section spacing */
            --section-padding: 100px;
            --section-padding-mobile: 60px;
            --content-max-width: 65ch; /* Optimal reading width */
            
            /* Urgency/Conversion colors */
            --color-urgency: #D97706; /* Warm amber */
            --color-urgency-light: #FEF3C7;
            --color-success: #059669; /* Green for checkmarks */
            --color-danger: #DC2626; /* Red for X marks */
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
            scroll-padding-top: var(--header-height);
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        /* Accessible focus styles - never remove outlines */
        :focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
        }

        /* Ensure focus is visible on all interactive elements */
        a:focus-visible,
        button:focus-visible,
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible,
        [tabindex]:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
            border-radius: 4px;
        }

        /* High contrast focus for buttons */
        .btn:focus-visible {
            outline: 3px solid var(--color-accent);
            outline-offset: 3px;
            box-shadow: 0 0 0 6px rgba(8, 145, 178, 0.2);
        }

        /* CRITICAL: Prevent horizontal overflow at document level */
        html, body {
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            width: 100%;
            max-width: 100%;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #F0F4F8;
        }
        ::-webkit-scrollbar-thumb {
            background: #CBD5E1;
            border-radius: 5px;
            border: 2px solid #F0F4F8;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94A3B8;
        }

        /* Custom Selection Color */
        ::selection {
            background: rgba(6, 182, 212, 0.2);
            color: var(--color-dark);
        }

        body {
            background-color: var(--color-bg);
            color: var(--color-text-main);
            font-family: var(--font-body);
            line-height: 1.6;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: var(--font-heading);
            font-weight: 700;
            line-height: 1.1;
            letter-spacing: -0.02em;
            color: var(--color-dark);
        }

        h1 { font-size: clamp(2.5rem, 5vw, 3.75rem); margin-bottom: 1.5rem; }
        h2 { font-size: clamp(2rem, 4vw, 2.75rem); margin-bottom: 1rem; }
        h3 { font-size: 1.5rem; margin-bottom: 0.75rem; }

        p {
            max-width: var(--content-max-width);
            line-height: 1.7;
        }

        a {
            text-decoration: none;
            color: inherit;
            transition: 0.3s;
        }

        ul { list-style: none; }
        img { max-width: 100%; display: block; height: auto; }
        
        /* Prevent CLS with aspect-ratio for key images */
        .hero-image-wrapper img {
            aspect-ratio: 3/2;
            object-fit: cover;
        }
        
        .gallery-main img {
            aspect-ratio: 3/2;
            object-fit: cover;
        }
        
        .comp-img img {
            aspect-ratio: 5/3;
            object-fit: cover;
        }

        /* UTILITIES */
        .container {
            max-width: var(--container-width);
            margin: 0 auto;
            padding: 0 20px;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 16px 32px;
            font-weight: 600;
            border-radius: 100px;
            transition: all 0.4s var(--ease-out-expo);
            cursor: pointer;
            font-size: 1rem;
            letter-spacing: 0.01em;
        }

        .btn-primary {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 18px 36px;
            font-weight: 700;
            border-radius: 100px;
            transition: transform 0.25s var(--ease-out-expo), box-shadow 0.25s var(--ease-out-expo), background 0.25s ease-out;
            cursor: pointer;
            font-size: 1.05rem;
            letter-spacing: 0.01em;
            background: linear-gradient(135deg, var(--color-dark), #020617);
            color: white;
            border: none;
            box-shadow: 0 4px 20px rgba(15, 23, 42, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            min-height: 52px;
            min-width: 160px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(15, 23, 42, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .btn-secondary {
            background: transparent;
            color: var(--color-dark);
            border: 2px solid rgba(15, 23, 42, 0.2);
            backdrop-filter: blur(4px);
            /* Accessibility: minimum touch target size */
            min-height: 48px;
            min-width: 120px;
        }

        .btn-secondary:hover {
            border-color: var(--color-dark);
            background: rgba(15, 23, 42, 0.05);
            transform: translateY(-2px);
        }
        
        /* CTA Button - Consistent with Primary but Accent Color */
        .btn-cta {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 18px 36px;
            font-weight: 700;
            font-size: 1.05rem;
            border-radius: 100px;
            border: none;
            cursor: pointer;
            letter-spacing: 0.01em;
            background: linear-gradient(135deg, var(--color-accent), #0E7490);
            color: white;
            box-shadow: 0 6px 24px rgba(8, 145, 178, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transition: transform 0.25s var(--ease-out-expo), box-shadow 0.25s var(--ease-out-expo);
            min-height: 52px;
            min-width: 180px;
            position: relative;
            overflow: hidden;
            /* Subtle attention pulse */
            animation: ctaAttention 3s ease-in-out infinite;
        }
        
        @keyframes ctaAttention {
            0%, 100% { box-shadow: 0 6px 24px rgba(8, 145, 178, 0.35), inset 0 1px 0 rgba(255, 255, 255, 0.15); }
            50% { box-shadow: 0 8px 32px rgba(8, 145, 178, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.15); }
        }
        
        .btn-cta:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(8, 145, 178, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
        
        /* Gallery Thumbs */
        .gallery-main img {
            width: 100%;
            max-width: 100%;
            height: auto;
        }

        .gallery-thumbs {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .gallery-thumbs .thumb {
            border: 2px solid transparent;
            border-radius: 12px;
            transition: all 0.2s ease;
            cursor: pointer;
            opacity: 0.7;
        }
        .gallery-thumbs .thumb:hover {
            opacity: 1;
        }
        .gallery-thumbs .thumb.active {
            border-color: var(--color-accent);
            opacity: 1;
            box-shadow: 0 0 0 2px rgba(8, 145, 178, 0.2);
        }

        .gallery-thumbs img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 10px;
        }

        /* Visually Hidden for Accessibility */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* ========================================
           TRUST BADGE STRIP
           ======================================== */
        .trust-strip {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(16px, 4vw, 32px);
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 16px;
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.04);
            flex-wrap: wrap;
            margin: 24px 0;
        }
        
        .trust-strip-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--color-text-main);
            white-space: nowrap;
        }
        
        .trust-strip-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-accent);
        }
        
        .trust-strip-icon svg {
            width: 100%;
            height: 100%;
        }
        
        /* ========================================
           URGENCY MESSAGING
           ======================================== */
        .urgency-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--color-urgency-light);
            border: 1px solid rgba(217, 119, 6, 0.2);
            border-radius: 100px;
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--color-urgency);
        }
        
        .urgency-badge svg {
            width: 16px;
            height: 16px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(0.95); }
        }
        
        .price-block {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 20px 0;
        }
        
        .price-main {
            display: flex;
            align-items: baseline;
            gap: 12px;
        }
        
        .price-current {
            font-size: 2rem;
            font-weight: 700;
            color: var(--color-dark);
            font-family: var(--font-heading);
        }
        
        .price-original {
            font-size: 1.1rem;
            color: var(--color-text-muted);
            text-decoration: line-through;
            opacity: 0.7;
        }
        
        .price-savings {
            font-size: 0.85rem;
            color: var(--color-success);
            font-weight: 600;
            background: rgba(5, 150, 105, 0.1);
            padding: 4px 10px;
            border-radius: 100px;
        }
        
        .price-intro {
            font-size: 0.8rem;
            color: var(--color-urgency);
            font-weight: 500;
        }
        
        /* ========================================
           COMPARISON SECTION
           ======================================== */
        .comparison-section {
            padding: 80px 0;
            background: linear-gradient(180deg, #F8FAFC 0%, #FFFFFF 100%);
            position: relative;
            overflow: hidden;
        }
        
        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            max-width: 900px;
            margin: 40px auto 0;
        }
        
        .comparison-column {
            background: white;
            border-radius: 20px;
            padding: 32px;
            border: 1px solid #E5E7EB;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.04);
        }
        
        .comparison-column.smartsplash {
            background: linear-gradient(135deg, #F0FDFA 0%, #FFFFFF 100%);
            border: 2px solid var(--color-accent);
            box-shadow: 0 8px 32px rgba(8, 145, 178, 0.12);
            position: relative;
        }
        
        .comparison-column.smartsplash::before {
            content: 'RECOMMENDED';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--color-accent);
            color: white;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 4px 12px;
            border-radius: 100px;
            letter-spacing: 0.05em;
        }
        
        .comparison-column-header {
            text-align: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }
        
        .comparison-column-header h4 {
            font-size: 1.15rem;
            margin-bottom: 4px;
        }
        
        .comparison-column-header p {
            font-size: 0.85rem;
            color: var(--color-text-muted);
            margin: 0;
        }
        
        .comparison-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .comparison-list li {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.04);
            font-size: 0.95rem;
        }
        
        .comparison-list li:last-child {
            border-bottom: none;
        }
        
        .comparison-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .comparison-icon.check {
            background: rgba(5, 150, 105, 0.12);
            color: var(--color-success);
        }
        
        .comparison-icon.x {
            background: rgba(220, 38, 38, 0.1);
            color: var(--color-danger);
        }
        
        .comparison-icon svg {
            width: 14px;
            height: 14px;
        }
        
        @media (max-width: 768px) {
            .comparison-table {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .comparison-column {
                padding: 24px;
            }
            
            .comparison-column.smartsplash::before {
                font-size: 0.65rem;
                padding: 3px 10px;
            }
        }
        
        /* ========================================
           ENHANCED REVIEW CARDS
           ======================================== */
        .reviewer-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(135deg, #E0F2FE, #CFFAFE);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            color: var(--color-accent);
            flex-shrink: 0;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
        }
        
        .reviewer-info {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .reviewer-details {
            flex: 1;
        }
        
        .reviewer-name {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--color-text-main);
            margin-bottom: 2px;
        }
        
        .reviewer-location {
            font-size: 0.8rem;
            color: var(--color-text-muted);
        }
        
        .star-rating {
            display: flex;
            gap: 2px;
            color: #F59E0B;
            font-size: 0.9rem;
        }
        
        .verified-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background: rgba(5, 150, 105, 0.1);
            color: var(--color-success);
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: 100px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .verified-badge svg {
            width: 12px;
            height: 12px;
        }
        
        /* ========================================
           VISUAL ASSET PLACEHOLDERS
           ======================================== */
        .visual-placeholder {
            width: 100%;
            aspect-ratio: 16/9;
            background: linear-gradient(135deg, #E0F2FE 0%, #CFFAFE 50%, #E0F2FE 100%);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 12px;
            color: var(--color-accent);
            font-size: 0.9rem;
            font-weight: 500;
            border: 2px dashed rgba(8, 145, 178, 0.3);
            overflow: hidden;
            position: relative;
        }
        
        .visual-placeholder-icon {
            width: 48px;
            height: 48px;
            opacity: 0.6;
        }
        
        .guarantee-banner {
            padding: 40px;
            background: linear-gradient(135deg, #0F172A, #1E293B);
            border-radius: 20px;
            color: white;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .guarantee-banner::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(6, 182, 212, 0.1) 0%, transparent 60%);
            pointer-events: none;
        }
        
        .guarantee-icon {
            width: 64px;
            height: 64px;
            background: rgba(6, 182, 212, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 16px;
            color: #22D3EE;
        }
        
        .guarantee-icon svg {
            width: 32px;
            height: 32px;
        }
        
        .guarantee-banner h3 {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }
        
        .guarantee-banner p {
            font-size: 0.95rem;
            opacity: 0.85;
            max-width: 500px;
            margin: 0 auto;
        }

        /* Accessible focus states */
        .btn:focus-visible,
        .thumb:focus-visible,
        .color-opt:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 3px;
        }

        /* Make sure interactive gallery/color elements show pointer */
        .thumb,
        .color-opt {
            cursor: pointer;
        }

        /* ANIMATIONS */
        /* COOLER 3D REVEAL ANIMATION */
        .reveal-on-scroll {
            opacity: 0;
            /* Start slightly rotated, pushed back, and blurred for cinematic depth */
            transform: perspective(1000px) rotateX(10deg) translateY(30px) scale(0.95);
            filter: blur(4px);
            transition:
                opacity 0.8s ease-out,
                transform 0.8s var(--ease-out-expo),
                filter 0.8s ease-out;
            will-change: opacity, transform, filter;
        }

        .reveal-on-scroll.is-visible {
            opacity: 1;
            transform: perspective(1000px) rotateX(0) translateY(0) scale(1);
            filter: blur(0);
        }

        /* HEADER - Realistic Frosted Glass with Dynamic Condensation */
        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: auto;
            height: var(--header-height);
            z-index: 100;
            transition: background 0.6s ease-out, backdrop-filter 0.6s ease-out, box-shadow 0.4s ease-out;
            display: flex;
            align-items: center;
            /* Frosted glass base - stable blue-tinted, with subtle hover-time fade */
            --hover-fade: 0;
            --panel-fade: 0;
            background:
                /* Subtle brightness gradient for tilt illusion - brighter at top (closer to viewer) */
                linear-gradient(
                    178deg,
                    rgba(255, 255, 255, 0.14) 0%,
                    rgba(255, 255, 255, 0.06) 40%,
                    rgba(255, 255, 255, 0.02) 100%
                ),
                /* Main frosted glass with aqua tint */
                linear-gradient(
                    175deg,
                    rgba(175, 220, 245, calc(0.78 - var(--hover-fade, 0) * 0.04)) 0%,
                    rgba(160, 210, 240, calc(0.74 - var(--hover-fade, 0) * 0.035)) 25%,
                    rgba(148, 200, 235, calc(0.72 - var(--hover-fade, 0) * 0.035)) 50%,
                    rgba(155, 205, 238, calc(0.73 - var(--hover-fade, 0) * 0.035)) 75%,
                    rgba(168, 215, 242, calc(0.76 - var(--hover-fade, 0) * 0.04)) 100%
                );
            backdrop-filter: blur(18px) saturate(1.55) brightness(calc(1.04 - var(--hover-fade, 0) * 0.025));
            -webkit-backdrop-filter: blur(18px) saturate(1.55) brightness(calc(1.04 - var(--hover-fade, 0) * 0.025));
            overflow: hidden;
            /* Subtle inner shadow for glass depth */
            box-shadow:
                inset 0 -1px 0 rgba(255, 255, 255, 0.15),
                inset 0 1px 2px rgba(255, 255, 255, 0.08),
                0 1px 3px rgba(0, 50, 80, 0.06);
        }

        /* Canvas layer for dynamic condensation spots */
        .condensation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }
        
        /* Shadow canvas for wiped areas (crater darkening effect) */
        .shadow-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        /* Full-page water canvas - covers entire viewport, fixed position */
        .page-water-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 95; /* Above most content but below header (z-index 100) */
            mix-blend-mode: normal;
            opacity: 0.92;
        }
        
        /* Hide water canvas on reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .page-water-canvas {
                display: none;
            }
        }
        
        /* Hide water canvas on touch/no-hover devices */
        @media (hover: none) {
            .page-water-canvas {
                display: none;
            }
        }

        /* Touch / no-hover devices: disable interactive wipe effect */
        @media (hover: none) {
            .condensation-canvas,
            .shadow-canvas {
                /* Touch devices still see static condensation */
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            .condensation-canvas,
            .shadow-canvas {
                /* Reduced motion - no animations */
            }
        }

        /* Glass edge with natural water beading at bottom - crevice where water collects */
        header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 6px;
            pointer-events: none;
            z-index: 2;
            background:
                /* Water beads forming at bottom edge - uneven spacing, more prominent */
                radial-gradient(ellipse 4px 6px at 5% 30%, rgba(255,255,255,0.55) 0%, rgba(180,220,245,0.25) 50%, transparent 100%),
                radial-gradient(ellipse 5px 8px at 12% 25%, rgba(255,255,255,0.6) 0%, rgba(175,215,242,0.30) 45%, transparent 100%),
                radial-gradient(ellipse 3px 5px at 21% 35%, rgba(255,255,255,0.52) 0%, rgba(170,210,238,0.24) 50%, transparent 100%),
                radial-gradient(ellipse 6px 10px at 32% 20%, rgba(255,255,255,0.62) 0%, rgba(178,218,245,0.32) 42%, transparent 100%),
                radial-gradient(ellipse 4px 6px at 43% 30%, rgba(255,255,255,0.55) 0%, rgba(172,212,240,0.28) 48%, transparent 100%),
                radial-gradient(ellipse 5px 9px at 55% 22%, rgba(255,255,255,0.58) 0%, rgba(175,215,242,0.30) 45%, transparent 100%),
                radial-gradient(ellipse 3px 5px at 65% 32%, rgba(255,255,255,0.52) 0%, rgba(168,208,238,0.25) 50%, transparent 100%),
                radial-gradient(ellipse 4px 7px at 76% 28%, rgba(255,255,255,0.56) 0%, rgba(175,215,242,0.28) 46%, transparent 100%),
                radial-gradient(ellipse 5px 8px at 88% 24%, rgba(255,255,255,0.6) 0%, rgba(178,218,245,0.32) 44%, transparent 100%),
                radial-gradient(ellipse 3px 5px at 95% 30%, rgba(255,255,255,0.54) 0%, rgba(172,212,240,0.26) 48%, transparent 100%),
                /* Bottom edge shadow line for depth */
                linear-gradient(
                    180deg,
                    transparent 0%,
                    rgba(120, 160, 190, 0.08) 60%,
                    rgba(100, 145, 175, 0.12) 100%
                ),
                /* Subtle edge highlight */
                linear-gradient(
                    90deg,
                    transparent 0%,
                    rgba(255, 255, 255, 0.28) 10%,
                    rgba(230, 245, 255, 0.22) 30%,
                    rgba(225, 242, 252, 0.25) 50%,
                    rgba(230, 245, 255, 0.22) 70%,
                    rgba(255, 255, 255, 0.28) 90%,
                    transparent 100%
                );
            opacity: 0.92;
        }

        /* Glass tilt illusion with micro-imperfections (chips/nicks) */
        header::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                /* Micro glass imperfections - tiny chips/nicks along edges */
                radial-gradient(1px 1px at 3% 15%, rgba(180, 210, 230, 0.18) 0%, transparent 80%),
                radial-gradient(0.8px 0.8px at 8% 85%, rgba(170, 200, 220, 0.15) 0%, transparent 75%),
                radial-gradient(1.2px 1.2px at 15% 8%, rgba(160, 195, 218, 0.12) 0%, transparent 70%),
                radial-gradient(0.6px 0.6px at 24% 92%, rgba(175, 205, 225, 0.14) 0%, transparent 78%),
                radial-gradient(1px 1px at 38% 4%, rgba(165, 198, 220, 0.11) 0%, transparent 72%),
                radial-gradient(0.7px 0.7px at 52% 96%, rgba(172, 202, 222, 0.13) 0%, transparent 76%),
                radial-gradient(1.1px 1.1px at 67% 6%, rgba(168, 200, 220, 0.10) 0%, transparent 74%),
                radial-gradient(0.9px 0.9px at 78% 88%, rgba(178, 208, 228, 0.16) 0%, transparent 77%),
                radial-gradient(0.8px 0.8px at 85% 12%, rgba(162, 196, 218, 0.12) 0%, transparent 73%),
                radial-gradient(1px 1px at 93% 90%, rgba(170, 200, 222, 0.14) 0%, transparent 75%),
                radial-gradient(0.5px 0.5px at 97% 50%, rgba(165, 198, 220, 0.10) 0%, transparent 70%),
                /* Larger subtle dust specks */
                radial-gradient(2px 2px at 18% 30%, rgba(255, 255, 255, 0.10) 0%, transparent 70%),
                radial-gradient(1.5px 1.5px at 46% 18%, rgba(255, 255, 255, 0.08) 0%, transparent 68%),
                radial-gradient(2px 2px at 72% 28%, rgba(255, 255, 255, 0.07) 0%, transparent 70%),
                /* Tilt sheen gradient - brighter edge at top */
                linear-gradient(178deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.03) 50%, rgba(200, 220, 235, 0.02) 100%);
            transform-origin: center top;
            transform: perspective(1400px) rotateX(-0.25deg) rotateY(0.4deg) translateY(-0.5px);
            will-change: transform, opacity;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes condensationBreath {
            0%, 100% {
                opacity: 0.95;
            }
            30% {
                opacity: 1;
            }
            60% {
                opacity: 0.92;
            }
            80% {
                opacity: 0.98;
            }
        }

        header.scrolled {
            /* Keep glass appearance stable on scroll: only add elevation shadow */
            box-shadow:
                inset 0 -1px 0 rgba(255, 255, 255, 0.12),
                inset 0 1px 2px rgba(255, 255, 255, 0.06),
                0 4px 24px rgba(8, 145, 178, 0.14),
                0 1px 4px rgba(0, 40, 60, 0.08);
        }

        header.scrolled .condensation-canvas {
            /* No scroll-based opacity change for condensation */
        }

        header.scrolled::after {
            /* Keep same edge highlight on scroll for visual stability */
        }

        /* Header CTA - prominent on scroll */
        header.scrolled .header-cta {
            background: linear-gradient(135deg, var(--color-accent), #0E7490);
            color: white;
            box-shadow: 0 4px 18px rgba(8, 145, 178, 0.35);
        }

        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            position: relative;
            z-index: 10; /* Ensure nav content is above condensation layer */
        }

        .logo {
            font-family: var(--font-heading);
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--color-dark);
            letter-spacing: -0.03em;
            transition: transform 0.25s var(--ease-out-expo), text-shadow 0.25s ease-out, letter-spacing 0.25s ease-out;
        }

        .logo:hover {
            transform: translateY(-1px);
            letter-spacing: -0.01em;
            text-shadow: 0 4px 12px rgba(15, 23, 42, 0.35);
        }

        .nav-links {
            display: flex;
            gap: 32px;
        }

        .nav-links a {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--color-text-main);
            position: relative;
            letter-spacing: 0.01em;
            transition: color 0.3s, letter-spacing 0.3s var(--ease-out-expo);
        }

        .nav-links a::after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--color-accent);
            transition: width 0.3s var(--ease-out-expo);
        }

        .nav-links a:hover {
            color: var(--color-accent);
            letter-spacing: 0.04em; /* Subtle letter-spacing expansion on hover */
        }

        .nav-links a:hover::after {
            width: 100%;
        }

        /* Mobile Hamburger Menu */
        .mobile-menu-toggle {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 44px;
            height: 44px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            z-index: 101;
        }

        .hamburger-line {
            width: 24px;
            height: 2px;
            background: var(--color-dark);
            margin: 3px 0;
            border-radius: 2px;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        .mobile-menu-toggle[aria-expanded="true"] .hamburger-line:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }

        .mobile-menu-toggle[aria-expanded="true"] .hamburger-line:nth-child(2) {
            opacity: 0;
        }

        .mobile-menu-toggle[aria-expanded="true"] .hamburger-line:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }

        @media (max-width: 768px) {
            .mobile-menu-toggle {
                display: flex;
                order: 3;
            }

            .nav-links {
                position: fixed;
                top: var(--header-height);
                left: 0;
                right: 0;
                background: rgba(255, 255, 255, 0.98);
                backdrop-filter: blur(20px);
                -webkit-backdrop-filter: blur(20px);
                flex-direction: column;
                padding: 24px;
                gap: 0;
                transform: translateY(-100%);
                opacity: 0;
                visibility: hidden;
                transition: transform 0.3s ease, opacity 0.3s ease, visibility 0.3s;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
                z-index: 99;
            }

            .nav-links.is-open {
                transform: translateY(0);
                opacity: 1;
                visibility: visible;
            }

            .nav-links a {
                display: block;
                padding: 16px 0;
                font-size: 1.1rem;
                border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            }

            .nav-links a:last-child {
                border-bottom: none;
            }

            .header-cta {
                order: 2;
            }
        }

        /* HERO - Organic splash-style background with puddle effect at bottom */
        .hero {
            padding-top: calc(var(--header-height) + 60px);
            padding-bottom: 80px;
            min-height: 90vh;
            display: flex;
            align-items: center;
            position: relative;
            overflow: hidden; /* CRITICAL: Prevent horizontal overflow from blobs */
            /* Main background - light teal wash at top, fading to white toward bottom */
            background:
                /* Top-heavy teal wash - more intense at top */
                radial-gradient(ellipse 90% 40% at 30% 15%, rgba(6, 182, 212, 0.18), transparent 60%),
                radial-gradient(ellipse 70% 35% at 75% 25%, rgba(8, 145, 178, 0.14), transparent 55%),
                radial-gradient(ellipse 100% 50% at 50% 20%, rgba(6, 182, 212, 0.10), transparent 70%),
                /* Subtle scattered puddles */
                radial-gradient(ellipse 40% 25% at 15% 40%, rgba(6, 182, 212, 0.08), transparent 50%),
                radial-gradient(ellipse 35% 30% at 85% 50%, rgba(8, 145, 178, 0.06), transparent 50%),
                /* Base gradient - light teal at top transitioning to near-white */
                linear-gradient(180deg,
                    rgba(224, 242, 248, 1) 0%,
                    rgba(235, 246, 250, 1) 30%,
                    rgba(245, 250, 252, 1) 60%,
                    rgba(255, 255, 255, 1) 100%
                );
        }

        /* Top blob decoration - DEEPER INTENSITY */
        .hero::before {
            content: '';
            position: absolute;
            top: -15%;
            left: 0; /* Changed from -10% to prevent overflow */
            width: 60%; /* Reduced from 70% */
            height: 55%;
            background: radial-gradient(ellipse at center, rgba(6, 182, 212, 0.18), transparent 65%);
            border-radius: 60% 40% 70% 30% / 50% 60% 40% 50%;
            filter: blur(50px);
            pointer-events: none;
            z-index: 0;
        }

        /* Right side blob decoration - DEEPER INTENSITY */
        .hero::after {
            content: '';
            position: absolute;
            top: -5%;
            right: 0; /* Changed from -15% to prevent overflow */
            width: 50%; /* Reduced from 60% */
            height: 50%;
            background: radial-gradient(ellipse at center, rgba(8, 145, 178, 0.15), transparent 60%);
            border-radius: 40% 60% 30% 70% / 60% 40% 60% 40%;
            filter: blur(55px);
            pointer-events: none;
            z-index: 0;
        }
        
        /* WATER SPLASH PUDDLE at bottom of hero - organic irregular edge */
        .hero-splash-puddle {
            position: absolute;
            bottom: -5px;
            left: 0;
            right: 0;
            width: 100%;
            height: 180px;
            pointer-events: none;
            z-index: 2;
            overflow: hidden; /* Changed from visible to prevent overflow */
        }
        
        .hero-splash-puddle svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .hero-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        .hero-text h1 {
            font-size: 4.5rem;
            line-height: 1.35; /* Increased vertical spacing between lines */
            margin-bottom: 24px;
            background: linear-gradient(135deg, var(--color-dark) 0%, #4B5563 100%);
            background-size: 100% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            /* Subtle ambient glow animation */
            animation: subtleGlow 4s ease-in-out infinite;
            position: relative;
            transition: background-size 0.3s ease-out;
        }

        /* Shimmer overlay on hover - organic puddle-shaped light reflection */
        .hero-text h1::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 130%;
            transform: translate(-50%, -50%);
            /* Soft radial glow - single blob */
            background: radial-gradient(
                ellipse 60% 70% at 50% 50%,
                rgba(255, 255, 255, 0.45) 0%,
                rgba(6, 182, 212, 0.3) 25%,
                rgba(255, 255, 255, 0.2) 45%,
                rgba(6, 182, 212, 0.15) 65%,
                transparent 85%
            );
            pointer-events: none;
            opacity: 0;
            mix-blend-mode: overlay;
            filter: blur(8px);
            /* Organic puddle/blob shape using clip-path polygon */
            clip-path: polygon(
                15% 20%,
                25% 8%,
                45% 12%,
                60% 5%,
                78% 15%,
                88% 10%,
                95% 25%,
                92% 45%,
                98% 60%,
                90% 78%,
                82% 92%,
                65% 88%,
                50% 95%,
                35% 90%,
                20% 95%,
                8% 82%,
                5% 65%,
                10% 45%,
                4% 30%
            );
        }

        .hero-text:hover h1::before {
            animation: shimmerPuddle 2s ease-in-out;
        }

        @keyframes shimmerPuddle {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
                filter: blur(12px);
            }
            30% {
                opacity: 0.9;
                transform: translate(-50%, -50%) scale(1.05);
                filter: blur(6px);
            }
            60% {
                opacity: 0.7;
                filter: blur(8px);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.15);
                filter: blur(14px);
            }
        }

        @keyframes subtleGlow {
            0%, 100% {
                filter: drop-shadow(0 0 0px rgba(8, 145, 178, 0));
                text-shadow: none;
            }
            50% {
                filter: drop-shadow(0 0 20px rgba(8, 145, 178, 0.15));
            }
        }

        .hero-text p {
            font-size: 1.25rem;
            color: var(--color-text-muted);
            margin-bottom: 40px;
            max-width: 520px;
        }

        .hero-actions {
            display: flex;
            gap: 16px;
        }

        .hero-image-wrapper {
            position: relative;
            border-radius: 24px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            transform: perspective(1000px) rotateY(-5deg);
            transition: transform 0.5s ease-out, box-shadow 0.5s ease-out;
            will-change: transform;
            z-index: 0;
        }

        /* soft glow behind product */
        .hero-image-wrapper::before {
            content: '';
            position: absolute;
            inset: 10%;
            border-radius: inherit;
            background: radial-gradient(circle at 30% 0%, rgba(6, 182, 212, 0.30), transparent 60%);
            filter: blur(18px);
            z-index: -1;
        }
        
        .hero-image-wrapper:hover {
            transform: perspective(1000px) rotateY(0deg) translateY(-4px);
            box-shadow: 0 26px 70px rgba(15, 23, 42, 0.35);
        }

        .hero-image-wrapper img {
            width: 102%;
            max-width: none;
            height: auto;
            display: block;
            /* Slight overscan so no sub-pixel gap can appear at container edges */
            transform: none;
            transition: none;
            margin-left: -1%;
        }

        .hero-image-wrapper:hover img {
            /* Very subtle scale on hover - barely perceptible */
            transform: scale(1.01);
            transition: transform 0.8s ease-out;
        }

        .floating-badge {
            position: absolute;
            top: 40px;
            right: 10px; /* Changed from -20px to stay within viewport */
            background: white;
            padding: 12px 24px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 0.9rem;
            animation: float 4s ease-in-out infinite;
        }

        .icon-check {
            width: 20px;
            height: 20px;
            background: var(--color-accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* PROBLEM / SOLUTION - Organic splash background */
        .problem-solution {
            padding: 100px 0;
            position: relative;
            overflow: hidden;
            /* Ambient inner shadow for depth */
            box-shadow: inset 0 20px 40px -20px rgba(6, 182, 212, 0.05);
            /* Multi-layered splash effect */
            background:
                /* Soft water stains */
                radial-gradient(ellipse 70% 50% at 5% 30%, rgba(255, 255, 255, 0.9), transparent 60%),
                radial-gradient(ellipse 50% 70% at 95% 70%, rgba(240, 253, 250, 0.8), transparent 55%),
                radial-gradient(ellipse 80% 40% at 50% 0%, rgba(207, 250, 254, 0.3), transparent 50%),
                /* Base white with slight gradient */
                linear-gradient(175deg, #FFFFFF 0%, #FAFEFE 50%, #F5FCFC 100%);
        }

        .problem-solution::before {
            content: '';
            position: absolute;
            top: -5%;
            left: 20%;
            width: 40%;
            height: 30%;
            background: radial-gradient(ellipse at center, rgba(6, 182, 212, 0.04), transparent 70%);
            border-radius: 50% 50% 60% 40% / 40% 60% 40% 60%;
            filter: blur(30px);
            pointer-events: none;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
        }

        .comp-card {
            background: var(--color-surface);
            border-radius: 24px;
            padding: 40px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.04);
            /* Immediate parallax - no transition delay, moves in sync with scroll */
            will-change: transform;
            /* No transition on transform - parallax should be instant with scroll */
        }

        .comp-card.problem {
            border: 1px solid #FECACA;
            background: linear-gradient(135deg, #FEF2F2 0%, #FFFFFF 100%);
        }

        .comp-card.solution {
            border: 1px solid #A5F3FC;
            background: linear-gradient(135deg, #F0FDFA 0%, #FFFFFF 100%);
        }

        /* Section-level blur effect - slow and smooth */
        .problem-solution {
            will-change: filter;
            transition: filter 0.8s ease-out;
        }

        .problem-solution.is-section-blurring {
            filter: blur(1.5px);
        }

        .comp-header {
            margin-bottom: 24px;
        }

        .comp-tag {
            text-transform: uppercase;
            font-size: 0.75rem;
            font-weight: 700;
            letter-spacing: 0.1em;
            margin-bottom: 8px;
            display: block;
        }

        .problem .comp-tag { color: #EF4444; }
        .solution .comp-tag { color: var(--color-accent); }

        .comp-img {
            border-radius: 16px;
            overflow: hidden;
            margin-top: 24px;
            height: 300px;
        }
        
        .comp-img img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* BENEFITS - Splash puddle background */
        .benefits {
            padding: 100px 0;
            position: relative;
            overflow: hidden;
            /* Performance optimization */
            contain: layout style paint;
            /* Ambient inner shadow for depth */
            box-shadow: inset 0 30px 60px -30px rgba(15, 23, 42, 0.03);
            /* Organic water-like gradients */
            background:
                /* Top left splash */
                radial-gradient(ellipse 60% 45% at 10% 20%, rgba(6, 182, 212, 0.08), transparent 65%),
                /* Bottom right puddle */
                radial-gradient(ellipse 55% 60% at 90% 85%, rgba(8, 145, 178, 0.06), transparent 60%),
                /* Center wash */
                radial-gradient(ellipse 90% 50% at 50% 50%, rgba(240, 244, 248, 0.5), transparent 70%),
                /* Scattered micro-puddles */
                radial-gradient(ellipse 20% 25% at 30% 70%, rgba(6, 182, 212, 0.04), transparent 50%),
                radial-gradient(ellipse 25% 20% at 70% 30%, rgba(8, 145, 178, 0.03), transparent 50%),
                /* Base */
                linear-gradient(170deg, #F0F4F8 0%, #EDF2F7 50%, #E8EEF4 100%);
        }

        .benefits::before {
            content: '';
            position: absolute;
            bottom: 10%;
            left: -5%;
            width: 35%;
            height: 40%;
            background: radial-gradient(ellipse at center, rgba(6, 182, 212, 0.05), transparent 65%);
            border-radius: 70% 30% 50% 50% / 50% 50% 70% 30%;
            filter: blur(35px);
            pointer-events: none;
        }

        .section-header {
            text-align: center;
            max-width: 650px;
            margin: 0 auto 60px;
            padding: 0 20px;
        }

        .section-header p {
            max-width: var(--content-max-width);
            margin: 0 auto;
            line-height: 1.7;
        }

        .section-header h2 {
            font-size: 2.5rem;
            margin-bottom: 16px;
            position: relative;
            display: inline-block;
        }

        /* Subtle accent line that animates in when section header reveals */
        .section-header h2::after {
            content: '';
            position: absolute;
            left: 50%;
            bottom: -8px;
            width: 72px;
            height: 3px;
            background: linear-gradient(90deg, rgba(6, 182, 212, 0.7), rgba(8, 145, 178, 0.08));
            border-radius: 999px;
            transform: translateX(-50%) scaleX(0.4);
            transform-origin: center;
            opacity: 0;
            transition: transform 0.6s var(--ease-out-expo), opacity 0.6s ease-out;
        }

        .section-header.reveal-on-scroll.is-visible h2::after {
            opacity: 1;
            transform: translateX(-50%) scaleX(1);
        }

        .benefits-grid {
            display: grid;
            /* FIX: Reduced minmax to 240px to ensure 4 cards fit on 1200px container */
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 30px;
        }

        .benefit-card {
            background: white;
            padding: 32px;
            border-radius: 20px;
            border: 1px solid transparent;
            /* Enhanced base shadow for "floating" feel */
            box-shadow: 0 4px 20px rgba(15, 23, 42, 0.03), 0 1px 3px rgba(0,0,0,0.02);
            /* Remove transform transition so parallax is instant, keep others for hover */
            transition: box-shadow 0.25s var(--ease-out-expo), border-color 0.25s ease-out, background 0.25s ease-out;
            will-change: transform, box-shadow;
        }

        .benefit-card:hover {
            transform: translateY(-6px);
            /* Deeper, softer shadow on hover */
            box-shadow: 0 24px 50px rgba(15, 23, 42, 0.08), 0 10px 20px rgba(6, 182, 212, 0.05);
            border-color: var(--color-accent-glow);
            background: radial-gradient(circle at top left, #ECFEFF, #FFFFFF 55%);
        }

        .benefit-icon {
            width: 48px;
            height: 48px;
            background: #ECFEFF;
            color: var(--color-accent);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
            font-size: 1.5rem;
            transition: transform 0.25s var(--ease-out-expo), box-shadow 0.25s var(--ease-out-expo), background 0.25s ease-out;
        }

        .benefit-card:hover .benefit-icon {
            transform: translateY(-2px) scale(1.05);
            background: #CFFAFE;
            box-shadow: 0 10px 25px rgba(6, 182, 212, 0.35);
        }
        
        .benefit-card h4 {
            font-size: 1.05rem;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--color-text-main);
        }
        
        .benefit-card p {
            font-size: 0.9rem;
            line-height: 1.65;
            color: var(--color-text-muted);
            margin: 0;
        }

        /* ========================================
           DECORATIVE ACCENT ELEMENTS
           Pure CSS decorations - no images needed
           Subtle, properly-sized visual touches
           ======================================== */
        
        /* Hide all image-based decorative accents - use CSS-only instead */
        /* .decorative-accent removed */
        
        /* CSS-ONLY DECORATIVE ELEMENTS - Properly sized and controlled */
        .css-accent {
            position: absolute;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Water droplet - CSS gradient circle */
        .css-accent.droplet {
            width: 24px;
            height: 24px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            background: radial-gradient(ellipse at 30% 20%,
                rgba(255,255,255,0.9) 0%,
                rgba(6, 182, 212, 0.5) 40%,
                rgba(8, 145, 178, 0.3) 100%);
            box-shadow: 0 2px 8px rgba(6, 182, 212, 0.25);
            opacity: 0.5;
            animation: floatDroplet 6s ease-in-out infinite;
        }
        
        /* Sparkle - CSS star shape */
        .css-accent.sparkle {
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, rgba(6, 182, 212, 0.8) 0%, transparent 70%);
            opacity: 0.4;
            animation: sparkleFloat 5s ease-in-out infinite;
        }
        
        .css-accent.sparkle::before,
        .css-accent.sparkle::after {
            content: '';
            position: absolute;
            background: linear-gradient(90deg, transparent, rgba(6, 182, 212, 0.6), transparent);
        }
        
        .css-accent.sparkle::before {
            width: 100%;
            height: 2px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        .css-accent.sparkle::after {
            width: 2px;
            height: 100%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        
        /* Badge - CSS checkmark circle */
        .css-accent.badge {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.3) 0%, rgba(8, 145, 178, 0.2) 100%);
            border: 1px solid rgba(6, 182, 212, 0.3);
            opacity: 0.45;
            animation: pulseBadge 4s ease-in-out infinite;
        }
        
        @keyframes floatDroplet {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-4px) rotate(2deg); }
            50% { transform: translateY(-1px) rotate(-1deg); }
            75% { transform: translateY(-5px) rotate(1deg); }
        }
        
        @keyframes sparkleFloat {
            0%, 100% { transform: scale(1); opacity: 0.4; }
            50% { transform: scale(1.15); opacity: 0.6; }
        }
        
        @keyframes pulseBadge {
            0%, 100% { transform: scale(1); opacity: 0.45; }
            50% { transform: scale(1.05); opacity: 0.55; }
        }
        
        /* Hide CSS accents on mobile for cleaner look */
        @media (max-width: 768px) {
            .css-accent {
                display: none;
            }
        }
        
        /* Respect reduced motion */
        @media (prefers-reduced-motion: reduce) {
            .css-accent {
                animation: none;
            }
        }

        /* HOW IT WORKS - Dark with subtle water reflections - EXTENDED EVEN LOWER */
        .how-it-works {
            padding: 100px 0 220px 0; /* Extended bottom padding even more */
            position: relative;
            overflow: hidden;
            color: white;
            /* Deep inner shadow to feel like a pool */
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.3);
            /* Dark splash effect */
            background:
                /* Subtle teal reflections like light on dark water */
                radial-gradient(ellipse 70% 40% at 20% 20%, rgba(6, 182, 212, 0.08), transparent 60%),
                radial-gradient(ellipse 50% 60% at 80% 80%, rgba(8, 145, 178, 0.06), transparent 55%),
                radial-gradient(ellipse 60% 30% at 60% 10%, rgba(6, 182, 212, 0.04), transparent 50%),
                /* Dark gradient base */
                linear-gradient(175deg, #1E293B 0%, #172033 50%, #0F172A 100%);
        }

        .how-it-works::before {
            content: '';
            position: absolute;
            top: 20%;
            right: 0; /* Changed from -10% to prevent overflow */
            width: 40%; /* Reduced from 50% */
            height: 60%;
            background: radial-gradient(ellipse at center, rgba(6, 182, 212, 0.03), transparent 60%);
            border-radius: 40% 60% 50% 50% / 60% 40% 60% 40%;
            filter: blur(40px);
            pointer-events: none;
        }

        .steps-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 40px;
            margin-top: 60px;
            position: relative;
        }

        .step-line {
            position: absolute;
            top: 24px;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255,255,255,0.1);
            z-index: 0;
        }

        .step-progress {
            position: absolute;
            top: 24px;
            left: 0;
            width: 0%;
            height: 2px;
            background: var(--color-accent);
            z-index: 0;
            transition: width 1s ease-out;
        }

        .step-item {
            position: relative;
            z-index: 1;
            /* Enable smooth parallax */
            will-change: transform;
        }

        .step-number {
            width: 50px;
            height: 50px;
            background: transparent; /* Transparent so we can layer pseudos behind */
            border: 2px solid var(--color-accent);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            color: white;
            margin-bottom: 24px;
            --glow-opacity: 0;
            transition: transform 0.2s ease-out, border-color 0.2s ease;
            position: relative;
            overflow: hidden;
            z-index: 1;
            cursor: default;
            isolation: isolate; /* Creates a new stacking context */
        }
        
        .step-number:hover {
            transform: scale(1.1);
            border-color: white;
        }
        
        .step-item h3 {
            font-size: 1.15rem;
            font-weight: 600;
            color: white;
            margin-bottom: 12px;
        }
        
        .step-item p {
            font-size: 0.9rem;
            line-height: 1.65;
            color: #9CA3AF;
            margin: 0;
        }

        /* 1. The dark background base (bottom layer) */
        .step-number::after {
            content: '';
            position: absolute;
            inset: 0;
            background: #0F172A;
            z-index: -2;
        }

        /* 2. The glow overlay (middle layer) */
        .step-number::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, var(--color-accent) 0%, transparent 70%);
            opacity: var(--glow-opacity);
            z-index: -1;
            transition: opacity 0.1s linear;
            mix-blend-mode: screen; /* Makes the glow look more vibrant */
        }

        /* PRODUCT DETAIL - Clean with subtle splash accents */
        .product-detail {
            padding: 100px 0;
            position: relative;
            overflow: hidden;
            /* Very subtle organic background */
            background:
                radial-gradient(ellipse 80% 50% at 10% 60%, rgba(6, 182, 212, 0.05), transparent 60%),
                radial-gradient(ellipse 60% 70% at 95% 30%, rgba(8, 145, 178, 0.04), transparent 55%),
                radial-gradient(ellipse 100% 40% at 50% 100%, rgba(240, 244, 248, 0.8), transparent 60%),
                linear-gradient(180deg, #F0F4F8 0%, #F5F8FA 50%, #F0F4F8 100%);
        }

        .product-grid {
            display: grid;
            grid-template-columns: 1.2fr 1fr;
            gap: 60px;
        }

        .product-gallery {
            width: 100%;
        }

        .gallery-main {
            border-radius: 24px;
            overflow: hidden;
            background: #eee;
            margin-bottom: 20px;
            position: relative;
        }

        /* SPLASH CONTAINER - holds ALL splash elements */
        .splash-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
            overflow: visible; /* Let splash go outside */
            border-radius: inherit;
        }

        /* MAIN WATER DROPLET - larger, more visible, water-like */
        .water-droplet {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            /* Rich water blue/teal gradient - MORE VISIBLE */
            background: radial-gradient(ellipse at 30% 20%,
                rgba(255, 255, 255, 0.95) 0%,
                rgba(100, 200, 230, 0.9) 20%,
                rgba(8, 145, 178, 0.85) 50%,
                rgba(6, 100, 140, 0.7) 100%
            );
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.2),
                0 0 8px rgba(8, 145, 178, 0.6),
                0 0 15px rgba(6, 182, 212, 0.4),
                inset 0 -2px 4px rgba(0, 50, 100, 0.3);
            opacity: 0;
        }

        /* SMALL MIST PARTICLE - secondary spray */
        .mist-particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle,
                rgba(180, 220, 240, 0.8) 0%,
                rgba(8, 145, 178, 0.5) 70%,
                transparent 100%
            );
            box-shadow: 0 0 6px rgba(8, 145, 178, 0.4);
            opacity: 0;
        }

        /* SPLASH RING - expanding ring effect at impact */
        .splash-ring {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            border: 2px solid rgba(8, 145, 178, 0.6);
            background: transparent;
            opacity: 0;
        }

        .gallery-main img {
            display: block;
            width: 100%;
            height: auto;
            transition: opacity 0.12s ease-out, transform 0.12s ease-out;
        }

        .gallery-main img.is-fading-out {
            opacity: 0;
            transform: scale(0.99);
        }

        .gallery-main img.is-fading-in {
            opacity: 1;
            transform: scale(1);
        }

        .gallery-thumbs {
            display: flex;
            gap: 16px;
            justify-content: flex-start;
        }

        .thumb {
            width: 80px;
            height: 80px;
            border-radius: 12px;
            overflow: hidden;
            opacity: 0.6;
            border: 2px solid transparent;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.2s ease-out;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .thumb:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.12);
        }

        .thumb:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: 2px;
            opacity: 1;
        }

        .thumb.active {
            opacity: 1;
            border: 2px solid var(--color-accent);
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px rgba(8, 145, 178, 0.15);
        }

        .product-info h2 {
            font-size: 3rem;
            margin-bottom: 16px;
        }

        .price {
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--color-text-muted);
            margin-bottom: 32px;
        }

        .price span {
            color: var(--color-dark);
            font-weight: 700;
            font-size: 2rem;
            margin-right: 8px;
            display: inline-block;
            animation: priceAttention 3s ease-in-out infinite;
            /* Soft glow pulse for subtle attention */
            text-shadow: 0 0 0 transparent;
            position: relative;
        }

        .price span::after {
            content: '';
            position: absolute;
            inset: -4px -8px;
            border-radius: 8px;
            background: radial-gradient(ellipse at center, rgba(8, 145, 178, 0.08), transparent 70%);
            opacity: 0;
            animation: priceGlowPulse 3s ease-in-out infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes priceAttention {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.03); }
        }

        @keyframes priceGlowPulse {
            0%, 100% { opacity: 0; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
        }

        .variant-selector {
            margin-bottom: 32px;
        }

        .variant-label {
            font-weight: 600;
            margin-bottom: 12px;
            display: block;
        }

        .color-options {
            display: flex;
            gap: 12px;
        }

        .color-opt {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid transparent;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out, border-color 0.2s ease-out;
        }

        .color-opt:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
        }

        .color-opt.selected {
            border-color: var(--color-dark);
            transform: scale(1.1);
        }

        .add-to-cart-block {
            display: flex;
            gap: 16px;
            margin-bottom: 32px;
        }

        .qty-input {
            width: 80px;
            padding: 0 16px;
            border: 1px solid #ddd;
            border-radius: 100px;
            text-align: center;
            font-size: 1rem;
        }

        .trust-badges {
            display: flex;
            gap: 24px;
            padding-top: 24px;
            border-top: 1px solid #eee;
        }

        .trust-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--color-text-muted);
            transition: transform 0.25s var(--ease-out-expo), color 0.25s ease-out;
            cursor: default;
            /* Gentle breathing animation */
            animation: trustBreathe 4s ease-in-out infinite;
        }

        /* Stagger the breathing animation for each trust item */
        .trust-item:nth-child(1) { animation-delay: 0s; }
        .trust-item:nth-child(2) { animation-delay: 0.5s; }
        .trust-item:nth-child(3) { animation-delay: 1s; }

        @keyframes trustBreathe {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.015); opacity: 0.95; }
        }

        .trust-item:hover {
            transform: translateY(-2px) scale(1.02);
            color: var(--color-text-main);
            animation-play-state: paused; /* Pause breathing on hover */
        }

        .trust-item span {
            transition: transform 0.25s var(--ease-out-expo);
        }

        .trust-item:hover span {
            transform: scale(1.15);
        }

        /* Product bullets inside buy box */
        .product-bullets {
            margin: 0 0 32px;
            padding-left: 0;
            list-style: none;
            color: var(--color-text-muted);
            font-size: 0.95rem;
        }

        .product-bullets li {
            margin-bottom: 10px;
            padding-left: 1.5rem;
            position: relative;
        }

        .product-bullets li::before {
            content: '✓';
            position: absolute;
            left: 0;
            color: var(--color-accent);
            font-weight: 700;
            animation: checkPop 0.4s var(--ease-out-expo) backwards;
        }

        .product-bullets li:nth-child(1)::before { animation-delay: 0.1s; }
        .product-bullets li:nth-child(2)::before { animation-delay: 0.2s; }
        .product-bullets li:nth-child(3)::before { animation-delay: 0.3s; }
        .product-bullets li:nth-child(4)::before { animation-delay: 0.4s; }

        @keyframes checkPop {
            0% { transform: scale(0) rotate(-45deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }

        /* REVIEWS / STORIES - Soft splash background */
        .reviews {
            padding: 100px 0;
            position: relative;
            overflow: hidden;
            /* Organic white with subtle color washes */
            background:
                radial-gradient(ellipse 60% 50% at 15% 25%, rgba(6, 182, 212, 0.05), transparent 60%),
                radial-gradient(ellipse 70% 45% at 85% 75%, rgba(8, 145, 178, 0.04), transparent 55%),
                radial-gradient(ellipse 50% 30% at 50% 10%, rgba(207, 250, 254, 0.3), transparent 50%),
                linear-gradient(170deg, #FFFFFF 0%, #FCFEFE 50%, #FAFCFC 100%);
        }

        .reviews::before {
            content: '';
            position: absolute;
            top: -10%;
            left: 60%;
            width: 45%;
            height: 35%;
            background: radial-gradient(ellipse at center, rgba(6, 182, 212, 0.03), transparent 65%);
            border-radius: 55% 45% 60% 40% / 45% 55% 45% 55%;
            filter: blur(30px);
            pointer-events: none;
        }

        .reviews-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 30px;
        }

        .review-card {
            background: #FFFFFF;
            border-radius: 20px;
            padding: 28px;
            border: 1px solid #E5E7EB;
            /* Enhanced shadow */
            box-shadow: 0 10px 30px rgba(15, 23, 42, 0.04), 0 4px 6px rgba(0,0,0,0.01);
            transition: transform 0.15s ease-out, box-shadow 0.25s var(--ease-out-expo), border-color 0.25s ease-out;
            transform-style: preserve-3d;
            perspective: 1000px;
        }

        /* Micro-stagger for review card reveal - subtle sequential entry */
        .review-card.reveal-on-scroll:nth-child(1) { transition-delay: 0s; }
        .review-card.reveal-on-scroll:nth-child(2) { transition-delay: 0.08s; }
        .review-card.reveal-on-scroll:nth-child(3) { transition-delay: 0.16s; }

        .review-card:hover {
            box-shadow: 0 18px 45px rgba(15, 23, 42, 0.07);
            border-color: var(--color-accent-glow);
            /* Transform is now controlled by JS for tilt effect */
        }

        .review-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            padding: 4px 10px;
            border-radius: 999px;
            background: #ECFEFF;
            color: #0369A1;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .review-card h4 {
            margin-bottom: 12px;
            font-size: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--color-text-main);
        }

        .review-card p {
            color: var(--color-text-muted);
            font-size: 0.9rem;
            line-height: 1.7;
            margin: 0;
        }
        
        .review-meta {
            margin-top: 16px;
            padding-top: 12px;
            border-top: 1px solid rgba(0,0,0,0.06);
            font-weight: 600;
            color: var(--color-text-main);
            font-size: 0.85rem;
            font-style: italic;
        }

        /* FAQ - Subtle organic background */
        .faq {
            padding: 100px 0;
            position: relative;
            overflow: hidden;
            /* Layered splash effect */
            background:
                radial-gradient(ellipse 55% 60% at 5% 50%, rgba(6, 182, 212, 0.06), transparent 55%),
                radial-gradient(ellipse 65% 45% at 95% 40%, rgba(8, 145, 178, 0.05), transparent 60%),
                radial-gradient(ellipse 40% 30% at 40% 90%, rgba(6, 182, 212, 0.03), transparent 50%),
                radial-gradient(ellipse 35% 40% at 70% 10%, rgba(8, 145, 178, 0.02), transparent 45%),
                linear-gradient(175deg, #F9FAFB 0%, #F5F7F9 50%, #F0F3F6 100%);
        }

        .faq::after {
            content: '';
            position: absolute;
            bottom: -5%;
            right: 20%;
            width: 40%;
            height: 30%;
            background: radial-gradient(ellipse at center, rgba(6, 182, 212, 0.04), transparent 60%);
            border-radius: 45% 55% 40% 60% / 55% 45% 55% 45%;
            filter: blur(25px);
            pointer-events: none;
        }

        .faq-grid {
            max-width: 800px;
            margin: 0 auto;
            display: grid;
            gap: 20px;
        }

        .faq-item {
            background: #FFFFFF;
            border-radius: 16px;
            padding: 0; /* Changed - padding now on internal elements */
            border: 1px solid #E5E7EB;
            /* Subtle shadow for separation */
            box-shadow: 0 4px 12px rgba(0,0,0,0.02);
            /* Enable smooth parallax */
            will-change: transform;
            overflow: hidden;
        }

        .faq-question {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            cursor: pointer;
            background: transparent;
            border: none;
            width: 100%;
            text-align: left;
            font-family: inherit;
            transition: background 0.2s ease;
            min-height: 64px; /* Ensure adequate touch target */
        }
        
        .faq-question:hover {
            background: rgba(6, 182, 212, 0.03);
        }
        
        .faq-question:focus-visible {
            outline: 2px solid var(--color-accent);
            outline-offset: -2px;
        }

        .faq-question-text {
            margin: 0;
            font-size: 1.05rem;
            font-weight: 600;
            color: var(--color-text-main);
            flex: 1;
            padding-right: 16px;
            text-align: left;
            line-height: 1.4;
        }
        
        .faq-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(6, 182, 212, 0.1);
            color: var(--color-accent);
            font-size: 1.4rem;
            font-weight: 300;
            transition: transform 0.3s ease, background 0.3s ease;
            flex-shrink: 0;
        }
        
        .faq-item[aria-expanded="true"] .faq-icon,
        .faq-item.is-open .faq-icon {
            transform: rotate(45deg);
            background: var(--color-accent);
            color: white;
        }
        
        .faq-answer {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.35s ease-out, padding 0.35s ease-out;
        }
        
        .faq-item[aria-expanded="true"] .faq-answer,
        .faq-item.is-open .faq-answer {
            max-height: 400px; /* Increased to accommodate longer answers */
        }

        .faq-item p {
            font-size: 0.95rem;
            color: var(--color-text-muted);
            line-height: 1.7;
            padding: 0 24px 20px 24px;
            margin: 0;
            max-width: 65ch; /* Comfortable reading width */
        }

        .faq-item h3 {
            margin: 0;
            padding: 0;
            font-size: inherit;
            font-weight: inherit;
        }

        /* PARTICLE SYSTEM */
        .particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            right: 0; /* Use left/right to prevent overflow */
            bottom: 0;
            width: auto;
            height: auto;
            pointer-events: none;
            z-index: 9999;
        }

        /* MERCURY BLOB CURSOR - Paler, more translucent */
        .mercury-orb {
            position: fixed;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 9998;
            /* PALER - more white/translucent with subtle blue tint */
            background: radial-gradient(circle at 35% 35%,
                rgba(255, 255, 255, 0.85) 0%,
                rgba(200, 230, 245, 0.6) 40%,
                rgba(150, 200, 230, 0.4) 70%,
                rgba(100, 180, 220, 0.2) 100%
            );
            box-shadow:
                0 0 8px rgba(255, 255, 255, 0.5),
                0 0 12px rgba(150, 200, 230, 0.4),
                inset 0 0 4px rgba(255, 255, 255, 0.6);
            /* Transform origin at center for proper scaling/stretching */
            transform-origin: center center;
            opacity: 0;
            transition: opacity 0.4s ease-out;
            /* Will be controlled by JS for blob deformation */
            /* Prevent this from causing overflow */
            max-width: 100%;
        }

        .mercury-orb.is-visible {
            opacity: 1;
        }

        /* SATELLITE DROPLETS - tiny orbiting droplets */
        .satellite-container {
            position: fixed;
            pointer-events: none;
            z-index: 9997;
        }

        .satellite-droplet {
            position: fixed;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            pointer-events: none;
            /* Even paler than main orb */
            background: radial-gradient(circle at 40% 40%,
                rgba(255, 255, 255, 0.9) 0%,
                rgba(180, 220, 240, 0.5) 60%,
                rgba(140, 190, 220, 0.2) 100%
            );
            box-shadow:
                0 0 4px rgba(255, 255, 255, 0.4),
                0 0 8px rgba(150, 200, 230, 0.3);
            opacity: 0;
            transform: translate(-50%, -50%);
            transition: opacity 0.2s ease-out;
        }

        .satellite-droplet.is-active {
            opacity: 1;
        }

        /* Hide on mobile/touch devices */
        @media (hover: none), (max-width: 768px) {
            .mercury-orb,
            .satellite-container,
            .satellite-droplet {
                display: none;
            }
        }

        /* Hide when reduced motion is preferred */
        @media (prefers-reduced-motion: reduce) {
            .mercury-orb,
            .satellite-container,
            .satellite-droplet {
                display: none;
            }
        }

        /* REFINED ANIMATIONS - Subtle Images, Active Components */
        
        /* Very subtle wiggle for main images */
        @keyframes wiggle {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(0.5px, -0.5px) rotate(0.05deg); }
            50% { transform: translate(-0.25px, 0.5px) rotate(-0.05deg); }
            75% { transform: translate(-0.5px, -0.25px) rotate(0.05deg); }
        }

        /* More active "jiggle" for secondary components */
        @keyframes jiggleActive {
            0%, 100% { transform: translateY(0) rotate(0); }
            25% { transform: translateY(-3px) rotate(1deg); }
            50% { transform: translateY(0) rotate(0); }
            75% { transform: translateY(3px) rotate(-1deg); }
        }

        @keyframes floatY {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); } /* Increased float range */
        }

        .wiggle-img {
            animation: wiggle 6s ease-in-out infinite; /* Slower, more subtle */
            will-change: transform;
        }

        /* Apply active jiggle to icons/badges */
        .jiggle-active {
            animation: jiggleActive 4s ease-in-out infinite;
            will-change: transform;
        }

        .float-y {
            animation: floatY 4s ease-in-out infinite; /* Slightly faster float */
            will-change: transform;
        }

        .float-x {
            animation: floatX 6s ease-in-out infinite;
            will-change: transform;
        }

        /* Parallax Wrappers */
        .parallax-wrapper {
            position: relative;
            z-index: 1;
        }

        .parallax-img {
            transition: transform 0.1s linear; /* Linear for smoother scroll sync */
            will-change: transform;
        }

        .parallax-text {
            transition: transform 0.1s linear;
            will-change: transform;
        }

        /* Different animation delays for variety */
        .wiggle-delay-1 { animation-delay: 0s; }
        .wiggle-delay-2 { animation-delay: 0.5s; }
        .wiggle-delay-3 { animation-delay: 1s; }
        .wiggle-delay-4 { animation-delay: 1.5s; }

        /* Respect users who prefer reduced motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }

            .floating-badge,
            .wiggle-img,
            .float-y,
            .float-x,
            .trust-item,
            .price span,
            .price span::after,
            .btn-cta {
                animation: none;
            }

            .parallax-img {
                transform: none !important;
            }

            .particle-canvas {
                display: none;
            }

            /* Disable hover shimmer and other micro-interactions */
            .hero-text h1::before {
                display: none;
            }
        }

        /* ========================================
           IMAGE HOVER 3D TILT + SPLASH EFFECT
           ======================================== */
        
        /* Wrapper for 3D perspective on images */
        .image-3d-tilt-wrapper {
            perspective: 1000px;
            transform-style: preserve-3d;
            display: inline-block;
            transition: transform 0.1s ease-out;
        }
        
        /* Image inside wrapper gets the actual 3D rotation */
        .image-3d-tilt-wrapper img {
            transition: transform 0.15s ease-out, box-shadow 0.25s ease-out;
            transform-style: preserve-3d;
            will-change: transform;
        }
        
        /* Subtle shadow enhancement on tilt */
        .image-3d-tilt-wrapper.is-tilting img {
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }
        
        /* ========================================
           SOFTER IMAGE CORNERS + WATER WOBBLE ANIMATION
           ======================================== */
        
        /* Subtle water wobble animation - very gentle organic sway */
        @keyframes waterWobble {
            0%, 100% {
                transform: scale(1) rotate(0deg) skew(0deg, 0deg);
            }
            20% {
                transform: scale(1.002) rotate(0.15deg) skew(0.1deg, -0.1deg);
            }
            40% {
                transform: scale(0.998) rotate(-0.1deg) skew(-0.05deg, 0.1deg);
            }
            60% {
                transform: scale(1.001) rotate(0.1deg) skew(0.08deg, -0.05deg);
            }
            80% {
                transform: scale(0.999) rotate(-0.12deg) skew(-0.08deg, 0.08deg);
            }
        }
        
        /* Apply MINIMAL corners to ALL main images - nearly square */
        .hero-image-wrapper,
        .gallery-main,
        .comp-img {
            border-radius: 6px !important; /* Very subtle - nearly square */
            overflow: hidden;
        }
        
        /* Main gallery slightly softer */
        .gallery-main {
            border-radius: 8px !important; /* Very subtle */
        }
        
        /* Images inside get matching radius and subtle wobble on hover */
        .hero-image-wrapper img,
        .gallery-main img,
        .comp-img img {
            border-radius: inherit;
        }
        
        /* Apply gentle wobble when hovering over image containers */
        .hero-image-wrapper:hover img,
        .gallery-main:hover img,
        .comp-img:hover img {
            animation: waterWobble 3s ease-in-out infinite;
        }
        
        /* Thumbnails - minimal corners */
        .thumb {
            border-radius: 4px !important; /* Nearly square */
        }
        
        /* Review cards - minimal */
        .review-card {
            border-radius: 8px; /* Reduced further */
        }
        
        /* Benefit cards - minimal */
        .benefit-card {
            border-radius: 8px; /* Reduced further */
        }
        
        /* Comparison cards - minimal */
        .comp-card {
            border-radius: 8px; /* Reduced further */
        }
        
        /* FAQ items - minimal */
        .faq-item {
            border-radius: 6px; /* Reduced further */
        }
        
        /* ========================================
           DECORATIVE CUT-OFF CIRCLE PATTERNS
           More contrasting partial circles as background decoration
           ======================================== */
        
        /* Base styles for decorative circles */
        .decorative-circle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            z-index: 0;
            /* CRITICAL: Ensure decorative elements don't cause overflow */
            max-width: 50vw;
        }
        
        /* Light teal/cyan circles for dark backgrounds - MORE VISIBLE */
        .decorative-circle.light {
            border: 2px solid rgba(6, 182, 212, 0.45);
            box-shadow: 0 0 20px rgba(6, 182, 212, 0.15);
        }
        
        /* Stronger light variant */
        .decorative-circle.light-strong {
            border: 3px solid rgba(6, 182, 212, 0.6);
            box-shadow: 0 0 30px rgba(6, 182, 212, 0.2);
        }
        
        /* Dark blue/teal circles for light backgrounds - MORE VISIBLE */
        .decorative-circle.dark {
            border: 2px solid rgba(8, 145, 178, 0.18);
        }
        
        /* Stronger dark variant */
        .decorative-circle.dark-strong {
            border: 3px solid rgba(8, 145, 178, 0.25);
        }
        
        /* Accent teal for white/very light sections */
        .decorative-circle.teal {
            border: 2px solid rgba(6, 182, 212, 0.22);
        }
        
        .decorative-circle.teal-strong {
            border: 3px solid rgba(6, 182, 212, 0.32);
        }
        
        /* Wave separator styling - taller waves with fade effect for seamless transitions */
        .wave-separator {
            position: relative;
            width: 100%;
            overflow: hidden; /* Changed from visible to prevent overflow */
            line-height: 0;
            /* Overlap with adjacent sections to eliminate straight lines */
            margin-top: -30px;
            margin-bottom: -30px;
            z-index: 5;
        }
        
        .wave-separator svg {
            width: 100%;
            height: 100px; /* Taller waves */
            display: block;
            /* Subtle drop shadow for depth */
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.03));
        }
        
        .wave-separator.flip {
            transform: rotate(180deg);
        }
        
        /* Add fade effect using mask-image for smooth blending */
        .wave-separator.fade-top svg {
            mask-image: linear-gradient(to bottom, transparent 0%, black 30%, black 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 30%, black 100%);
        }
        
        .wave-separator.fade-bottom svg {
            mask-image: linear-gradient(to bottom, black 0%, black 70%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 0%, black 70%, transparent 100%);
        }
        
        .wave-separator.fade-both svg {
            mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 20%, black 80%, transparent 100%);
        }
        
        @media (max-width: 768px) {
            .wave-separator svg {
                height: 60px;
            }
            .wave-separator {
                margin-top: -20px;
                margin-bottom: -20px;
            }
        }
        
        /* SPLASH PUDDLE SEPARATOR - Organic water splash transition */
        /* Used for How It Works → Reviews transition (dark blue to white) */
        .splash-puddle-separator {
            position: relative;
            width: 100%;
            height: 140px; /* Taller for more organic splash effect */
            overflow: hidden; /* Changed from visible to prevent overflow */
            line-height: 0;
            /* Overlap with adjacent sections to eliminate gaps */
            margin-top: -50px;
            margin-bottom: -50px;
            z-index: 5;
        }
        
        .splash-puddle-separator svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        /* Specific styles for How It Works → Reviews handled by SVG */
        
        @media (max-width: 768px) {
            .splash-puddle-separator {
                height: 100px;
                margin-top: -35px;
                margin-bottom: -35px;
            }
        }
        
        /* Container for hover splash particles */
        .image-splash-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 20;
            overflow: visible;
            border-radius: inherit;
        }
        
        /* Hover splash droplet - larger than cursor trail */
        .image-hover-droplet {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            /* DARKER water gradient - deeper teal/blue tones */
            background: radial-gradient(ellipse at 30% 20%,
                rgba(200, 235, 245, 0.85) 0%,
                rgba(6, 120, 160, 0.8) 25%,
                rgba(4, 100, 140, 0.75) 55%,
                rgba(2, 70, 110, 0.65) 100%
            );
            box-shadow:
                0 2px 6px rgba(0, 0, 0, 0.2),
                0 0 10px rgba(4, 100, 140, 0.5),
                0 0 16px rgba(2, 70, 110, 0.35),
                inset 0 -2px 5px rgba(0, 40, 80, 0.3);
            opacity: 0;
            transform-origin: center center;
        }
        
        /* Ripple ring effect on image */
        .image-hover-ripple {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            border: 2px solid rgba(8, 145, 178, 0.5);
            background: transparent;
            opacity: 0;
            transform: translate(-50%, -50%);
        }
        
        /* Hide effects on touch devices and reduced motion */
        @media (hover: none), (max-width: 768px) {
            .image-3d-tilt-wrapper img {
                transform: none !important;
            }
            .image-splash-container {
                display: none;
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            .image-3d-tilt-wrapper img {
                transform: none !important;
                transition: none !important;
            }
            .image-splash-container {
                display: none;
            }
        }

        /* ========================================
           MOBILE RESPONSIVE - COMPREHENSIVE OVERHAUL
           Strategy: Scale down, reduce density, prioritize content
           ======================================== */
        
        /* Tablet breakpoint (768px - 1024px) */
        @media (max-width: 1024px) {
            :root {
                --header-height: 70px;
            }
            
            .hero-text h1 {
                font-size: 3.5rem;
            }
            
            .section-header h2 {
                font-size: 2rem;
            }
            
            .product-info h2 {
                font-size: 2.5rem;
            }
            
            .benefits-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 24px;
            }
            
            .reviews-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        
        /* Mobile breakpoint (768px and below) */
        @media (max-width: 768px) {
            /* ===== GLOBAL MOBILE SCALING ===== */
            :root {
                --header-height: 60px;
            }
            
            body {
                font-size: 15px;
                line-height: 1.5;
                overflow-x: hidden;
            }
            
            .container {
                padding: 0 16px;
                max-width: 100%;
                overflow-x: hidden;
            }
            
            /* Prevent all horizontal overflow */
            * {
                max-width: 100%;
                box-sizing: border-box;
            }
            
            img {
                max-width: 100%;
                height: auto;
            }
            
            /* ===== TYPOGRAPHY SCALING ===== */
            h1, .hero-text h1 {
                font-size: 2rem !important; /* Significantly reduced from 3rem */
                line-height: 1.2;
                margin-bottom: 16px;
            }
            
            h2, .section-header h2, .product-info h2 {
                font-size: 1.5rem !important; /* Reduced from 2.5rem */
                margin-bottom: 12px;
            }
            
            h3 {
                font-size: 1.15rem;
            }
            
            h4 {
                font-size: 1rem;
            }
            
            p {
                font-size: 0.9rem;
                line-height: 1.55;
                max-width: 100%;
            }
            
            /* ===== SECTION PADDING REDUCTION ===== */
            .hero {
                padding-top: calc(var(--header-height) + 24px);
                padding-bottom: 40px;
                min-height: auto; /* Remove min-height to prevent excessive vertical space */
            }
            
            .problem-solution,
            .benefits,
            .how-it-works,
            .reviews,
            .product-detail,
            .faq {
                padding: 50px 0; /* Reduced from 100px */
            }
            
            /* How It Works extended section - reduce but still extended on mobile */
            .how-it-works {
                padding: 50px 0 120px 0; /* More bottom padding on mobile too */
            }
            
            /* ===== HERO SECTION MOBILE ===== */
            .hero-content {
                grid-template-columns: 1fr;
                text-align: center;
                gap: 32px;
            }
            
            .hero-text p {
                font-size: 0.95rem;
                margin-bottom: 24px;
                max-width: 100%;
            }
            
            .hero-actions {
                justify-content: center;
                flex-direction: column;
                gap: 12px;
            }
            
            .hero-actions .btn {
                width: 100%;
                padding: 14px 24px;
                font-size: 0.95rem;
            }
            
            /* Trust badges in hero - stack vertically on mobile */
            .hero-text > div[style*="margin-top: 16px"] {
                flex-direction: column;
                gap: 8px !important;
                font-size: 0.8rem;
            }
            
            .hero-text > div[style*="margin-top: 20px"] {
                flex-direction: column;
                gap: 8px !important;
                font-size: 0.85rem;
                text-align: center;
            }
            
            /* Hero image - contained on mobile */
            .hero-image-wrapper {
                transform: none !important;
                border-radius: 12px !important;
                max-width: 100%;
            }
            
            .hero-splash-puddle {
                height: 100px;
            }
            
            /* Parallax text - simplified on mobile */
            .parallax-text {
                transform: none !important;
            }
            
            /* ===== PROBLEM/SOLUTION MOBILE ===== */
            .comparison-grid {
                grid-template-columns: 1fr;
                gap: 24px;
            }
            
            .comp-card {
                padding: 24px;
                border-radius: 12px !important;
            }
            
            .comp-img {
                height: 180px; /* Reduced from 300px */
                margin-top: 16px;
            }
            
            .comp-header h3 {
                font-size: 1.1rem;
            }
            
            .comp-header p {
                font-size: 0.85rem;
            }
            
            /* ===== BENEFITS MOBILE ===== */
            .section-header {
                margin-bottom: 32px;
            }
            
            .section-header p {
                font-size: 0.9rem;
            }
            
            .benefits-grid {
                grid-template-columns: 1fr; /* Single column on mobile */
                gap: 16px;
            }
            
            .benefit-card {
                padding: 20px;
                border-radius: 12px !important;
            }
            
            .benefit-icon {
                width: 40px;
                height: 40px;
                font-size: 1.25rem;
                margin-bottom: 12px;
            }
            
            .benefit-card h4 {
                font-size: 1rem;
                margin-bottom: 8px;
            }
            
            .benefit-card p {
                font-size: 0.85rem;
            }
            
            /* ===== HOW IT WORKS MOBILE ===== */
            .steps-container {
                grid-template-columns: 1fr;
                gap: 32px;
                margin-top: 32px;
            }
            
            .step-line {
                display: none;
            }
            
            .step-item {
                text-align: center;
            }
            
            .step-number {
                width: 44px;
                height: 44px;
                margin: 0 auto 16px;
                font-size: 0.9rem;
            }
            
            .step-item h3 {
                font-size: 1.05rem;
            }
            
            .step-item p {
                font-size: 0.85rem;
            }
            
            .step-item > div[style*="font-size: 2rem"] {
                font-size: 1.5rem !important;
                margin-bottom: 8px !important;
            }
            
            /* ===== LIFESTYLE SHOWCASE MOBILE ===== */
            .lifestyle-showcase {
                margin-top: -100px !important; /* Increased to eliminate white gap between How It Works and image */
            }
            
            .lifestyle-showcase > div {
                height: 350px !important; /* Reduced from 500px */
            }
            
            .lifestyle-showcase .reveal-on-scroll {
                max-width: 100% !important;
            }
            
            .lifestyle-showcase .reveal-on-scroll > div {
                padding: 20px !important;
                margin: 0 16px;
                border-radius: 12px !important;
            }
            
            .lifestyle-showcase h2 {
                font-size: 1.5rem !important;
            }
            
            .lifestyle-showcase p {
                font-size: 0.9rem !important;
                margin-bottom: 16px !important;
            }
            
            .lifestyle-showcase .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }
            
            /* ===== REVIEWS MOBILE ===== */
            .reviews-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .review-card {
                padding: 20px;
                border-radius: 12px !important;
            }
            
            .review-card h4 {
                font-size: 0.95rem;
            }
            
            .review-card p {
                font-size: 0.85rem;
            }
            
            .review-meta {
                font-size: 0.8rem;
            }
            
            .review-badge {
                font-size: 0.65rem;
                padding: 3px 8px;
            }
            
            /* ===== PRODUCT DETAIL MOBILE ===== */
            .product-grid {
                grid-template-columns: 1fr;
                gap: 32px;
            }
            
            .gallery-main {
                border-radius: 12px !important;
            }
            
            .gallery-thumbs {
                gap: 8px;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .thumb {
                width: 56px;
                height: 56px;
                border-radius: 8px !important;
                flex-shrink: 0;
            }
            
            .product-info {
                text-align: center;
            }
            
            .price {
                font-size: 1.25rem;
                margin-bottom: 20px;
            }
            
            .price span {
                font-size: 1.5rem;
            }
            
            .product-bullets {
                text-align: left;
                font-size: 0.85rem;
            }
            
            .product-bullets li {
                margin-bottom: 8px;
            }
            
            .add-to-cart-block {
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .trust-badges {
                flex-wrap: wrap;
                justify-content: center;
                gap: 16px;
            }
            
            .trust-item {
                font-size: 0.8rem;
            }
            
            /* ===== FAQ MOBILE ===== */
            .faq-grid {
                gap: 12px;
            }
            
            .faq-item {
                border-radius: 12px !important;
            }
            
            .faq-question {
                padding: 16px 20px;
                min-height: 56px; /* Ensure adequate touch target */
            }
            
            .faq-question-text {
                font-size: 0.95rem;
            }
            
            .faq-item p {
                font-size: 0.85rem;
                padding: 0 20px 16px 20px;
            }
            
            /* ===== BUTTONS MOBILE ===== */
            .btn {
                padding: 12px 24px;
                font-size: 0.9rem;
            }
            
            .btn-primary {
                padding: 14px 28px;
            }
            
            /* ===== HEADER MOBILE ===== */
            .logo {
                font-size: 1.2rem;
            }
            
            .nav-links {
                display: none; /* Hide nav links on mobile */
            }
            
            header .btn-primary {
                padding: 8px 16px;
                font-size: 0.8rem;
            }
            
            /* ===== DECORATIVE ELEMENTS - HIDE ON MOBILE ===== */
            .decorative-circle {
                display: none !important; /* Hide circles to reduce clutter and prevent overflow */
            }
            
            .decorative-accent {
                display: none !important;
            }
            
            .css-accent {
                display: none !important;
            }
            
            /* ===== WAVE SEPARATORS MOBILE ===== */
            .wave-separator {
                margin-top: -15px;
                margin-bottom: -15px;
            }
            
            .wave-separator svg {
                height: 50px;
            }
            
            /* ===== ANIMATIONS - SIMPLIFIED ON MOBILE ===== */
            .floating-badge {
                display: none; /* Hide floating elements */
            }
            
            .wiggle-img,
            .float-y,
            .float-x,
            .jiggle-active {
                animation: none !important;
            }
            
            /* ===== FOOTER MOBILE ===== */
            footer {
                padding: 50px 0 30px;
            }
            
            footer .container > div[style*="gap: 24px"] {
                flex-direction: column;
                gap: 12px !important;
            }
        }
        
        /* Small mobile (480px and below) */
        @media (max-width: 480px) {
            h1, .hero-text h1 {
                font-size: 1.75rem !important;
            }
            
            h2, .section-header h2, .product-info h2 {
                font-size: 1.35rem !important;
            }
            
            .hero-text p {
                font-size: 0.9rem;
            }
            
            .comparison-grid {
                gap: 16px;
            }
            
            .comp-card {
                padding: 20px;
            }
            
            .comp-img {
                height: 150px;
            }
            
            .thumb {
                width: 52px;
                height: 52px;
            }
            
            .lifestyle-showcase > div {
                height: 300px !important;
            }
            
            .lifestyle-showcase .reveal-on-scroll > div {
                padding: 16px !important;
            }
        }
        
        /* Legacy mobile styles - consolidated above */

        /* Mobile bottom sticky CTA bar */
        .mobile-cta-bar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 90;
            display: none;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            padding-bottom: calc(14px + env(safe-area-inset-bottom, 0px)); /* iOS safe area */
            background: rgba(15, 23, 42, 0.98);
            color: #F9FAFB;
            box-shadow: 0 -4px 24px rgba(15, 23, 42, 0.35);
            /* Ensure it stays within viewport */
            max-width: 100%;
            box-sizing: border-box;
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
        }

        .mobile-cta-bar.is-visible {
            transform: translateY(0);
        }

        .mobile-cta-bar__info {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 0.85rem;
            min-width: 0; /* Allow text truncation */
        }
        .mobile-cta-bar__title {
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .mobile-cta-bar__subtitle {
            font-size: 0.7rem;
            opacity: 0.8;
        }
        .mobile-cta-bar__btn {
            flex-shrink: 0;
            min-height: 44px; /* Accessibility: minimum touch target */
            min-width: 140px;
            padding: 12px 20px;
            font-size: 0.9rem;
            /* Match primary CTA button styling */
            background: linear-gradient(135deg, var(--color-accent), #0E7490) !important;
            box-shadow: 0 4px 16px rgba(8, 145, 178, 0.35) !important;
        }

        .mobile-cta-bar__btn:hover,
        .mobile-cta-bar__btn:focus {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(8, 145, 178, 0.45) !important;
        }

        @media (max-width: 768px) {
            .mobile-cta-bar {
                display: flex;
            }
            body {
                /* Account for mobile sticky bar + safe area */
                padding-bottom: calc(80px + env(safe-area-inset-bottom, 0px));
            }
            
            /* Ensure all sections are contained */
            section {
                overflow: hidden;
            }
        }

        /* Desktop sticky CTA bar */
        .desktop-cta-bar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 90;
            display: none;
            padding: 16px 0;
            background: rgba(15, 23, 42, 0.98);
            color: #F9FAFB;
            box-shadow: 0 -4px 24px rgba(15, 23, 42, 0.35);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
        }

        @media (min-width: 769px) {
            .desktop-cta-bar {
                display: block;
            }
        }

        .desktop-cta-bar.is-visible {
            transform: translateY(0);
        }

        .desktop-cta-bar__content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 24px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 24px;
        }

        .desktop-cta-bar__info {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .desktop-cta-bar__title {
            font-weight: 700;
            font-size: 1.1rem;
            color: #F9FAFB;
        }

        .desktop-cta-bar__divider {
            color: rgba(249, 250, 251, 0.5);
            font-size: 0.9rem;
        }

        .desktop-cta-bar__price {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--color-accent);
        }

        .desktop-cta-bar__benefit {
            font-size: 0.95rem;
            color: rgba(249, 250, 251, 0.85);
        }

        .desktop-cta-bar__btn {
            flex-shrink: 0;
            min-height: 48px;
            padding: 14px 32px;
            font-size: 1rem;
            background: linear-gradient(135deg, var(--color-accent), #0E7490) !important;
            box-shadow: 0 4px 16px rgba(8, 145, 178, 0.35) !important;
        }

        .desktop-cta-bar__btn:hover,
        .desktop-cta-bar__btn:focus {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(8, 145, 178, 0.5) !important;
        }

        @media (min-width: 769px) {
            body {
                /* Account for desktop sticky bar */
                padding-bottom: 80px;
            }
        }

        /* Hero image sizing - contained properly */
        .hero-image-wrapper img {
            width: 100%;
            max-width: 100%;
            height: auto;
            display: block;
        }

        /* Mobile override: keep it simple and symmetrical */
        @media (max-width: 768px) {
            .hero-image-wrapper img {
                width: 100%;
                max-width: 100%;
                margin: 0;
            }
            
            /* Soften horizontal padding on mobile - consistent side padding */
            .container {
                padding-left: 16px;
                padding-right: 16px;
                max-width: 100%;
                box-sizing: border-box;
            }

            /* Hide floating badge on mobile to prevent overflow */
            .floating-badge {
                display: none;
            }

            /* Completely hide decorative circles on mobile */
            .decorative-circle {
                display: none !important;
            }
            
            /* Ensure ALL sections don't bleed */
            .hero,
            .problem-solution,
            .benefits,
            .how-it-works,
            .reviews,
            .product-detail,
            .faq,
            .lifestyle-showcase {
                overflow: hidden;
                max-width: 100%;
            }
            
            /* Prevent any element with position absolute/fixed from causing overflow */
            [style*="position: absolute"],
            [style*="position:absolute"] {
                max-width: 100%;
            }
        }

        /* Footer Links */
        .footer-link {
            color: var(--color-text-muted);
            transition: color 0.2s ease-out;
            text-decoration: none;
        }
        .footer-link:hover {
            color: var(--color-dark);
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- Skip to main content link for accessibility -->
    <a href="#main-content" class="visually-hidden" style="position: absolute; top: -40px; left: 0; background: var(--color-dark); color: white; padding: 8px 16px; z-index: 1000; transition: top 0.3s;" onfocus="this.style.top='0'" onblur="this.style.top='-40px'">Skip to main content</a>
    
    <!-- Particle Canvas for mouse trail effect -->
    <canvas id="particleCanvas" class="particle-canvas"></canvas>
    
    <!-- Mercury Orb Cursor Follower -->
    <div id="mercuryOrb" class="mercury-orb"></div>
    
    <!-- Satellite Droplets - orbit around the main mercury blob -->
    <div class="satellite-droplet" id="satellite1"></div>
    <div class="satellite-droplet" id="satellite2"></div>
    <div class="satellite-droplet" id="satellite3"></div>
    <canvas id="pageWaterCanvas" class="page-water-canvas"></canvas>

    <header id="header">
        <canvas class="condensation-canvas" id="condensationCanvas"></canvas>
        <canvas class="shadow-canvas" id="shadowCanvas"></canvas>
        <div class="container nav-container">
            <div class="logo">SmartSplash™</div>
            <!-- Mobile hamburger menu button -->
            <button class="mobile-menu-toggle" id="mobileMenuToggle" aria-label="Toggle navigation menu" aria-expanded="false" aria-controls="mainNav" data-analytics-id="nav_mobile_menu_toggle">
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
                <span class="hamburger-line"></span>
            </button>
            <nav class="nav-links" id="mainNav" aria-label="Main navigation">
                <a href="#how-it-works" data-analytics-id="nav_how_it_works">How It Works</a>
                <a href="#reviews" data-analytics-id="nav_reviews">Reviews</a>
                <a href="#faq" data-analytics-id="nav_faq">FAQ</a>
            </nav>
            <a href="#buy-now" class="btn btn-primary header-cta" style="padding: 10px 24px; font-size: 0.9rem;" data-analytics-id="cta_header_buy_now">Buy Now</a>
        </div>
    </header>

    <main id="main-content">
    <section class="hero" aria-labelledby="hero-heading">
        <!-- ORGANIC WATER SPLASH PUDDLE at bottom - irregular edge with varying intensity -->
        <div class="hero-splash-puddle">
            <svg viewBox="0 0 1440 180" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <!-- Gradient for intensity variation - more teal in some spots, more white in others -->
                    <linearGradient id="splashGradient1" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(6,182,212,0.15);stop-opacity:1" />
                        <stop offset="25%" style="stop-color:rgba(255,255,255,0.9);stop-opacity:1" />
                        <stop offset="40%" style="stop-color:rgba(8,145,178,0.12);stop-opacity:1" />
                        <stop offset="60%" style="stop-color:rgba(255,255,255,0.95);stop-opacity:1" />
                        <stop offset="80%" style="stop-color:rgba(6,182,212,0.10);stop-opacity:1" />
                        <stop offset="100%" style="stop-color:rgba(255,255,255,0.85);stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="splashGradient2" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" style="stop-color:rgba(255,255,255,0.7);stop-opacity:1" />
                        <stop offset="20%" style="stop-color:rgba(6,182,212,0.08);stop-opacity:1" />
                        <stop offset="45%" style="stop-color:rgba(255,255,255,0.85);stop-opacity:1" />
                        <stop offset="70%" style="stop-color:rgba(8,145,178,0.06);stop-opacity:1" />
                        <stop offset="100%" style="stop-color:rgba(255,255,255,0.9);stop-opacity:1" />
                    </linearGradient>
                    <!-- Solid white for the bottom fill -->
                    <linearGradient id="splashWhite" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#FFFFFF;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#FFFFFF;stop-opacity:1" />
                    </linearGradient>
                </defs>
                
                <!-- Layer 1: Deepest - subtle teal pools (most irregular) -->
                <path d="M0,120
                    C50,105 80,130 120,115
                    C160,100 200,125 260,108
                    C320,90 380,120 440,100
                    C500,80 540,110 600,95
                    C660,80 720,105 780,88
                    C840,70 900,100 960,85
                    C1020,70 1080,95 1140,80
                    C1200,65 1260,90 1320,75
                    C1380,60 1420,85 1440,70
                    L1440,180 L0,180 Z"
                    fill="url(#splashGradient1)" opacity="0.6"/>
                
                <!-- Layer 2: Middle - slightly higher, different rhythm -->
                <path d="M0,135
                    C70,120 100,145 170,128
                    C240,110 290,140 370,118
                    C450,95 510,130 590,105
                    C670,80 730,115 810,95
                    C890,75 950,108 1030,88
                    C1110,68 1170,100 1250,82
                    C1330,64 1390,95 1440,78
                    L1440,180 L0,180 Z"
                    fill="url(#splashGradient2)" opacity="0.7"/>
                
                <!-- Layer 3: Top edge - the main visible splash line (most prominent) -->
                <path d="M0,150
                    C40,142 70,158 130,145
                    C190,132 230,155 300,140
                    C370,125 420,150 500,135
                    C580,120 640,145 720,130
                    C800,115 860,142 940,125
                    C1020,108 1080,138 1160,120
                    C1240,102 1300,132 1380,115
                    C1420,105 1440,125 1440,115
                    L1440,180 L0,180 Z"
                    fill="#FFFFFF" opacity="1"/>
                
                <!-- Extra organic blob shapes for "puddle" feel - scattered water pools -->
                <ellipse cx="150" cy="155" rx="60" ry="15" fill="rgba(6,182,212,0.08)"/>
                <ellipse cx="450" cy="160" rx="80" ry="12" fill="rgba(8,145,178,0.06)"/>
                <ellipse cx="800" cy="158" rx="50" ry="10" fill="rgba(6,182,212,0.07)"/>
                <ellipse cx="1100" cy="162" rx="70" ry="14" fill="rgba(8,145,178,0.05)"/>
                <ellipse cx="1350" cy="156" rx="45" ry="11" fill="rgba(6,182,212,0.06)"/>
                
                <!-- Small scattered droplets for realism -->
                <circle cx="100" cy="140" r="4" fill="rgba(6,182,212,0.1)"/>
                <circle cx="280" cy="132" r="3" fill="rgba(8,145,178,0.08)"/>
                <circle cx="520" cy="128" r="5" fill="rgba(6,182,212,0.09)"/>
                <circle cx="680" cy="135" r="3" fill="rgba(8,145,178,0.07)"/>
                <circle cx="920" cy="118" r="4" fill="rgba(6,182,212,0.08)"/>
                <circle cx="1200" cy="125" r="5" fill="rgba(8,145,178,0.06)"/>
                <circle cx="1380" cy="108" r="3" fill="rgba(6,182,212,0.07)"/>
            </svg>
        </div>
        
        <div class="container hero-content">
            <div class="hero-text reveal-on-scroll">
                <!-- Staggered parallax for text elements -->
                <h1 id="hero-heading" class="parallax-text" data-parallax-speed="-0.08">Stop the Splash.<br>Save Your Shirt.</h1>
                <p class="parallax-text" data-parallax-speed="-0.04">Tired of walking away from the sink looking like you took a shower? The SmartSplash™ Silicone Sink Splash Guard suctions to the front edge of your sink to block rogue spray, keeping your shirt dry and your floor safely drip-free.</p>
                
                <div class="parallax-text" data-parallax-speed="-0.02" style="margin-bottom: 24px; display: flex; align-items: center; gap: 12px; font-size: 0.95rem; color: var(--color-text-muted);">
                    <span style="color: var(--color-accent); font-weight: 600;">✓ Fits Standard Sinks</span>
                    <span style="width: 4px; height: 4px; background: #cbd5e1; border-radius: 50%;"></span>
                    <span>Granite, Quartz & Stainless Steel</span>
                </div>

                <div class="hero-actions">
                    <a href="#buy-now" class="btn btn-cta" data-analytics-id="cta_hero_primary">Keep My Shirt Dry — Save 29% Today</a>
                    <a href="#how-it-works" class="btn btn-secondary" data-analytics-id="cta_hero_how_it_works">How It Works</a>
                </div>
                <div style="margin-top: 12px; font-size: 0.85rem; color: var(--color-text-muted); font-weight: 500;">
                    No outfit change, no mop required.
                </div>
                
                <!-- Trust Badge Strip - Unified Horizontal Bar -->
                <div class="trust-strip" style="margin-top: 20px; flex-wrap: wrap; justify-content: center; gap: 16px;">
                    <div class="trust-strip-item">
                        <span class="trust-strip-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle></svg>
                        </span>
                        <span>Free Shipping</span>
                    </div>
                    <div style="width: 1px; height: 16px; background: rgba(0,0,0,0.1); display: inline-block;"></div>
                    <div class="trust-strip-item">
                        <span class="trust-strip-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>
                        </span>
                        <span>30-Day Guarantee</span>
                    </div>
                    <div style="width: 1px; height: 16px; background: rgba(0,0,0,0.1); display: inline-block;"></div>
                    <div class="trust-strip-item">
                        <span class="trust-strip-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                        </span>
                        <span>Secure Checkout</span>
                    </div>
                </div>
                
                <!-- Price Block with Urgency and Discount Justification -->
                <div class="price-block" style="margin-top: 16px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                        <span class="urgency-badge">
                            <svg viewBox="0 0 24 24" fill="currentColor"><path d="M13 3L4 14h7l-2 7 9-11h-7l2-7z"/></svg>
                            Selling fast — limited stock this month
                        </span>
                    </div>
                    <div class="price-main">
                        <span class="price-current">$24.99</span>
                        <span class="price-original">$35.00</span>
                        <span class="price-savings">Save 29%</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 6px; font-size: 0.9rem; font-weight: 600; color: var(--color-text-main); margin-top: 4px;">
                        <span style="color: #F59E0B; letter-spacing: -2px;" aria-label="5 out of 5 stars" role="img">⭐⭐⭐⭐⭐</span>
                        <span>Rated 4.9 by 2,431 UK customers — 30-Day Dry Shirt Guarantee</span>
                    </div>
                    <div class="price-intro">Introductory launch pricing — originally $35</div>
                </div>
            </div>
            <div class="hero-image-wrapper reveal-on-scroll" style="transition-delay: 0.2s;">
                <img src="smart-splash-hero.webp" alt="SmartSplash Silicone Sink Splash Guard mounted on a modern kitchen sink, blocking water splashes" width="600" height="400" loading="eager" fetchpriority="high">
                <!-- Removed duplicate floating badge -->
            </div>
        </div>
    </section>

    <!-- Wave Separator: Hero → Problem/Solution (white) - with fade effect -->
    <div class="wave-separator flip fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #FFFFFF;">
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>

    <section class="problem-solution" style="position: relative;">
        <!-- Decorative cut-off circles - MORE CONTRASTING & MORE OF THEM -->
        <div class="decorative-circle teal-strong" style="width: 280px; height: 280px; top: -5%; left: -100px; clip-path: inset(0 0 0 35%);"></div>
        <div class="decorative-circle teal" style="width: 180px; height: 180px; top: 15%; left: -60px; clip-path: inset(0 0 0 33%);"></div>
        <div class="decorative-circle teal-strong" style="width: 220px; height: 220px; top: 40%; right: -80px; clip-path: inset(0 36% 0 0);"></div>
        <div class="decorative-circle teal" style="width: 120px; height: 120px; top: 70%; right: -40px; clip-path: inset(0 33% 0 0);"></div>
        <div class="decorative-circle teal" style="width: 150px; height: 150px; bottom: 5%; left: 15%; clip-path: inset(55% 0 0 0);"></div>
        <div class="decorative-circle teal-strong" style="width: 100px; height: 100px; bottom: 20%; left: 45%; clip-path: inset(0 0 50% 0);"></div>
        <div class="decorative-circle teal" style="width: 200px; height: 200px; top: 5%; right: 20%; clip-path: inset(0 0 0 60%);"></div>
        <div class="container">
            <!-- Before/After Visual -->
            <div class="reveal-on-scroll" style="margin-bottom: 40px; background: white; padding: 24px; border-radius: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.03); border: 1px solid #E5E7EB; max-width: 800px; margin-left: auto; margin-right: auto;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start;">
                    <div style="text-align: center;">
                        <div style="position: relative; border-radius: 12px; overflow: hidden; margin-bottom: 12px; aspect-ratio: 4/3; border: 2px solid #FECACA;">
                            <img src="generated-problem-splash.png" alt="Before SmartSplash - shirt wet" style="width: 100%; height: 100%; object-fit: cover;">
                            <div style="position: absolute; top: 10px; left: 10px; background: rgba(220, 38, 38, 0.9); color: white; padding: 4px 10px; border-radius: 100px; font-size: 0.75rem; font-weight: 700; letter-spacing: 0.05em;">BEFORE</div>
                        </div>
                        <p style="font-size: 0.95rem; line-height: 1.4; margin: 0;"><strong>Shirt wet</strong><br><span style="color: var(--color-text-muted); font-size: 0.9rem;">Water splashing over sink edge</span></p>
                    </div>
                    <div style="text-align: center;">
                        <div style="position: relative; border-radius: 12px; overflow: hidden; margin-bottom: 12px; aspect-ratio: 4/3; border: 2px solid var(--color-accent);">
                            <img src="smart-splash-after-v2.png" alt="After SmartSplash - shirt dry" style="width: 100%; height: 100%; object-fit: cover;">
                            <div style="position: absolute; top: 10px; left: 10px; background: var(--color-accent); color: white; padding: 4px 10px; border-radius: 100px; font-size: 0.75rem; font-weight: 700; letter-spacing: 0.05em;">AFTER</div>
                        </div>
                        <p style="font-size: 0.95rem; line-height: 1.4; margin: 0;"><strong>Shirt dry</strong><br><span style="color: var(--color-text-muted); font-size: 0.9rem;">Water redirected inward</span></p>
                    </div>
                </div>
            </div>

            <div class="comparison-grid">
                <div class="comp-card problem reveal-on-scroll">
                    <div class="comp-header">
                        <span class="comp-tag" aria-label="The Problem">The Problem</span>
                        <h3>Soaked Shirts & Slippery Floors</h3>
                        <p style="max-width: 100%;">High-pressure faucets, shallow sinks, and heavy pans send water straight over the rim—onto your clothes, cabinet doors, and the floor.</p>
                    </div>
                    <div class="comp-img">
                        <img src="smart-splash-problem.webp" alt="Water splashing from a kitchen sink faucet creating a wet mess on clothes and floor" width="500" height="300" style="filter: grayscale(30%); opacity: 0.9;" loading="lazy">
                    </div>
                </div>
                <div class="comp-card solution reveal-on-scroll" style="transition-delay: 0.2s;">
                    <div class="comp-header">
                        <span class="comp-tag" aria-label="The Fix">The Fix</span>
                        <h3>SmartSplash™ Silicone Sink Splash Guard</h3>
                        <p style="max-width: 100%;">A soft, high-wall silicone barrier with multi-point suction that catches splashes at the edge of your sink and guides water back into the basin—not onto you or the floor.</p>
                    </div>
                    <div class="comp-img">
                        <img src="smart-splash-solution.webp" alt="Kitchen sink with SmartSplash silicone splash guard installed, keeping water contained in the basin" width="500" height="300" loading="lazy">
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Wave Separator: Problem/Solution → Benefits (light gray) - with fade effect -->
    <div class="wave-separator fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #F0F4F8;">
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>

    <section class="benefits" style="position: relative;">
        <!-- Decorative cut-off circles - MORE CONTRASTING & MORE OF THEM -->
        <div class="decorative-circle dark-strong" style="width: 320px; height: 320px; top: -8%; right: -120px; clip-path: inset(0 37% 0 0);"></div>
        <div class="decorative-circle dark" style="width: 200px; height: 200px; top: 8%; right: -80px; clip-path: inset(0 40% 0 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 240px; height: 240px; bottom: 10%; left: -90px; clip-path: inset(0 0 0 37%);"></div>
        <div class="decorative-circle dark" style="width: 140px; height: 140px; bottom: 25%; left: -50px; clip-path: inset(0 0 0 35%);"></div>
        <div class="decorative-circle dark" style="width: 160px; height: 160px; top: 35%; left: 10%; clip-path: inset(0 0 55% 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 120px; height: 120px; top: 60%; left: 25%; clip-path: inset(50% 0 0 0);"></div>
        <div class="decorative-circle dark" style="width: 180px; height: 180px; top: 20%; left: 60%; clip-path: inset(0 55% 0 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 100px; height: 100px; bottom: 40%; right: 15%; clip-path: inset(0 0 0 50%);"></div>
        
        <!-- CSS-only decorative accents - subtle, properly-sized visual touches -->
        <div class="css-accent droplet" style="top: 15%; right: 8%;" aria-hidden="true"></div>
        <div class="css-accent sparkle" style="bottom: 20%; left: 12%;" aria-hidden="true"></div>
        <div class="css-accent badge" style="top: 55%; right: 18%;" aria-hidden="true"></div>
        <div class="css-accent droplet" style="bottom: 35%; right: 5%; animation-delay: 1.5s;" aria-hidden="true"></div>
        
        <div class="container">
            <div class="section-header reveal-on-scroll">
                <h2>Why Your Sink Needs This Guard</h2>
                <p>Designed for real-world kitchens with high-arc faucets, shallow basins, and busy families. If you’re tired of wet shirts, slippery floors, and constant mopping, this is for you.</p>
            </div>
            <div class="benefits-grid">
                <div class="benefit-card reveal-on-scroll">
                    <div class="benefit-icon jiggle-active">💧</div>
                    <h4>Stops Wet Shirts & Floors</h4>
                    <p>Creates a high-wall barrier that blocks splashes before they hit your clothes or drip onto the floor.</p>
                </div>
                <div class="benefit-card reveal-on-scroll" style="transition-delay: 0.1s;">
                    <div class="benefit-icon jiggle-active" style="animation-delay: 0.5s;">🛡️</div>
                    <h4>Soft, Flexible Silicone</h4>
                    <p>Bends comfortably when you lean against it—no rigid plastic digging into your stomach while you scrub.</p>
                </div>
                <div class="benefit-card reveal-on-scroll" style="transition-delay: 0.2s;">
                    <div class="benefit-icon jiggle-active" style="animation-delay: 1s;">🧲</div>
                    <h4>Secure Suction Grip</h4>
                    <p>Multiple suction cups lock onto smooth sink rims so the guard won’t slide around, even with heavy pots and pans.</p>
                </div>
                <div class="benefit-card reveal-on-scroll" style="transition-delay: 0.3s;">
                    <div class="benefit-icon jiggle-active" style="animation-delay: 1.5s;">✨</div>
                    <h4>Easy to Clean & Mold Resistant</h4>
                    <p>Non-porous silicone rinses clean in seconds or goes straight on the top rack of your dishwasher—no odors, no buildup.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Wave Separator: Benefits → How It Works (dark) - Full-width layered wave with fade -->
    <div class="wave-separator flip fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #1E293B;">
            <!-- Layer 1: Base wave covering full width -->
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <!-- Layer 2: Mid wave -->
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <!-- Layer 3: Top wave - full solid coverage -->
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>

    <section id="how-it-works" class="how-it-works" style="position: relative;" aria-labelledby="how-it-works-heading">
        <!-- Decorative cut-off circles (light on dark bg) - MORE CONTRASTING & MORE OF THEM -->
        <div class="decorative-circle light-strong" style="width: 350px; height: 350px; top: -10%; left: -140px; clip-path: inset(0 0 0 40%);"></div>
        <div class="decorative-circle light" style="width: 220px; height: 220px; top: 12%; left: -90px; clip-path: inset(0 0 0 40%);"></div>
        <div class="decorative-circle light-strong" style="width: 280px; height: 280px; bottom: 5%; right: -100px; clip-path: inset(0 35% 0 0);"></div>
        <div class="decorative-circle light" style="width: 160px; height: 160px; bottom: 18%; right: -60px; clip-path: inset(0 37% 0 0);"></div>
        <div class="decorative-circle light" style="width: 180px; height: 180px; top: 45%; right: 20%; clip-path: inset(50% 0 0 0);"></div>
        <div class="decorative-circle light-strong" style="width: 120px; height: 120px; top: 30%; left: 30%; clip-path: inset(0 0 55% 0);"></div>
        <div class="decorative-circle light" style="width: 140px; height: 140px; bottom: 35%; left: 20%; clip-path: inset(0 50% 0 0);"></div>
        <div class="decorative-circle light-strong" style="width: 100px; height: 100px; top: 65%; left: 55%; clip-path: inset(45% 0 0 0);"></div>
        <div class="decorative-circle light" style="width: 200px; height: 200px; top: 5%; right: 35%; clip-path: inset(0 0 0 60%);"></div>
        <div class="container">
            <div class="section-header reveal-on-scroll">
                <h2 id="how-it-works-heading" style="color: white;">How It Works</h2>
                <p style="color:#9CA3AF;">A simple, tool-free way to keep water where it belongs: in the sink.</p>
            </div>
            <div class="steps-container">
                <div class="step-line"></div>
                <div class="step-progress" id="stepProgress"></div>
                
                <div class="step-item reveal-on-scroll">
                    <div class="step-number">1</div>
                    <div style="font-size: 2rem; margin-bottom: 12px;">🧲</div>
                    <h3>Press & Stick in under 10 seconds</h3>
                    <p style="color: #9CA3AF;">Align SmartSplash™ with the front rim of your sink and press down each suction cup until it seals on the smooth surface.</p>
                </div>
                <div class="step-item reveal-on-scroll" style="transition-delay: 0.2s;">
                    <div class="step-number">2</div>
                    <div style="font-size: 2rem; margin-bottom: 12px;">💦</div>
                    <h3>Wash as Usual</h3>
                    <p style="color: #9CA3AF;">The curved, high-wall silicone barrier catches splashes and guides water back into the basin.</p>
                </div>
                <div class="step-item reveal-on-scroll" style="transition-delay: 0.4s;">
                    <div class="step-number">3</div>
                    <div style="font-size: 2rem; margin-bottom: 12px;">🔁</div>
                    <h3>Peel, Rinse, Store</h3>
                    <p style="color: #9CA3AF;">When you’re done, peel from one end to release the suction, rinse it off, or leave it in place ready for the next round of dishes.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- LIFESTYLE SHOWCASE - Full-width banner with AI-generated image -->
    <!-- No wave separator - image sits directly against the dark How It Works section -->
    <!-- Negative margin pulls the image up to touch the How It Works collar/header - increased to eliminate white gap -->
    <section class="lifestyle-showcase" style="position: relative; padding: 0; overflow: hidden; margin-top: -180px; z-index: 1;">
        <div style="position: relative; width: 100%; height: 500px; overflow: hidden;">
            <img src="smartsplash-lifestyle-kitchen.png" alt="Modern kitchen with SmartSplash silicone guard installed on sink, water redirected inward, user washing dishes with shirt fully dry" width="1200" height="500" style="width: 100%; height: 100%; object-fit: cover; object-position: center 30%;" loading="lazy" decoding="async">
            <!-- Enhanced gradient overlay for better text readability - STRONGER (0.92 to transparent) -->
            <div style="position: absolute; inset: 0; background: linear-gradient(to right, rgba(15, 23, 42, 0.92) 0%, rgba(15, 23, 42, 0.85) 20%, rgba(15, 23, 42, 0.7) 40%, rgba(15, 23, 42, 0.45) 60%, rgba(15, 23, 42, 0.2) 80%, transparent 100%);"></div>
            <!-- Content overlay -->
            <div class="container" style="position: absolute; top: 50%; left: 0; right: 0; transform: translateY(-50%); z-index: 2;">
                <div class="reveal-on-scroll" style="max-width: 520px; color: white;">
                    <!-- Frosted glass backing panel with backdrop-filter blur at 8px -->
                    <div style="background: rgba(15, 23, 42, 0.55); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border-radius: 16px; padding: 32px; border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
                        <span style="display: inline-block; padding: 6px 16px; background: rgba(6, 182, 212, 0.95); border-radius: 100px; font-size: 0.75rem; font-weight: 700; letter-spacing: 0.1em; text-transform: uppercase; margin-bottom: 16px; color: white;">The SmartSplash™ Difference</span>
                        <h2 style="font-size: 2.5rem; margin-bottom: 16px; color: #FFFFFF; line-height: 1.2; text-shadow: 0 4px 16px rgba(0,0,0,0.9), 0 2px 8px rgba(0,0,0,0.8), 0 1px 4px rgba(0,0,0,0.7);">Dishes Done.<br>Shirt Still Dry.</h2>
                        <p style="font-size: 1.1rem; margin-bottom: 24px; line-height: 1.7; color: #FFFFFF; font-weight: 400; text-shadow: 0 4px 12px rgba(0,0,0,0.95), 0 2px 6px rgba(0,0,0,0.85), 0 1px 3px rgba(0,0,0,0.75);">Join thousands of happy customers who've said goodbye to post-dishes outfit changes and hello to a calmer, drier kitchen routine.</p>
                        <a href="#buy-now" class="btn btn-primary" style="background: linear-gradient(135deg, #0891B2, #06B6D4); box-shadow: 0 4px 20px rgba(8, 145, 178, 0.4);" data-analytics-id="cta_lifestyle_get_yours">Get Yours Today</a>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Wave Separator: Lifestyle → Reviews (white) -->
    <div class="wave-separator flip fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #FFFFFF;">
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>

    <section id="reviews" class="reviews" style="position: relative;" aria-labelledby="reviews-heading">
        <!-- Decorative cut-off circles - MORE CONTRASTING & MORE OF THEM -->
        <div class="decorative-circle teal-strong" style="width: 280px; height: 280px; top: -5%; right: -110px; clip-path: inset(0 39% 0 0);"></div>
        <div class="decorative-circle teal" style="width: 170px; height: 170px; top: 10%; right: -70px; clip-path: inset(0 41% 0 0);"></div>
        <div class="decorative-circle teal-strong" style="width: 220px; height: 220px; bottom: 15%; left: -80px; clip-path: inset(0 0 0 36%);"></div>
        <div class="decorative-circle teal" style="width: 130px; height: 130px; bottom: 30%; left: -45px; clip-path: inset(0 0 0 34%);"></div>
        <div class="decorative-circle teal" style="width: 160px; height: 160px; top: 40%; left: 10%; clip-path: inset(55% 0 0 0);"></div>
        <div class="decorative-circle teal-strong" style="width: 120px; height: 120px; top: 25%; left: 40%; clip-path: inset(0 0 50% 0);"></div>
        <div class="decorative-circle teal" style="width: 180px; height: 180px; bottom: 5%; right: 25%; clip-path: inset(0 0 0 55%);"></div>
        <div class="decorative-circle teal-strong" style="width: 90px; height: 90px; top: 60%; right: 10%; clip-path: inset(50% 0 0 0);"></div>
        
        <!-- CSS-only decorative accents - subtle visual touches for Reviews section -->
        <div class="css-accent droplet" style="top: 8%; left: 15%; animation-delay: 0.3s;" aria-hidden="true"></div>
        <div class="css-accent sparkle" style="bottom: 15%; right: 8%; animation-delay: 1.2s;" aria-hidden="true"></div>
        <div class="css-accent badge" style="top: 45%; left: 5%; animation-delay: 0.7s;" aria-hidden="true"></div>
        
        <div class="container">
            <div class="section-header reveal-on-scroll">
                <h2 id="reviews-heading">Real Kitchens, Real Dry Shirts</h2>
                <p>SmartSplash™ slips into your existing routine—whether you're rinsing a single glass or tackling a mountain of pots.</p>
            </div>
            <div class="reviews-grid">
                <!-- Review Card 1 - Sarah with AI-generated portrait -->
                <div class="review-card reveal-on-scroll">
                    <div class="reviewer-info">
                        <div class="reviewer-avatar" style="padding: 0; overflow: hidden;">
                            <img src="reviewer-sarah.png" alt="" width="48" height="48" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" loading="lazy" decoding="async">
                        </div>
                        <div class="reviewer-details">
                            <div class="reviewer-name">Sarah M.</div>
                            <div class="reviewer-location">London, UK</div>
                        </div>
                        <div class="star-rating">★★★★★</div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span class="verified-badge">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                            Verified Purchase
                        </span>
                    </div>
                    <h4>"No more pre-dinner outfit changes."</h4>
                    <p>I was hosting friends for dinner. Ten minutes before guests arrived, I rinsed a few wine glasses and used to end up with a huge wet patch on my dress. With SmartSplash™ in place, the water stays in the sink and I greet guests looking polished, not damp.</p>
                </div>
                
                <!-- Review Card 2 - Mark with AI-generated portrait -->
                <div class="review-card reveal-on-scroll" style="transition-delay: 0.15s;">
                    <div class="reviewer-info">
                        <div class="reviewer-avatar" style="padding: 0; overflow: hidden;">
                            <img src="reviewer-mark.png" alt="" width="48" height="48" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" loading="lazy" decoding="async">
                        </div>
                        <div class="reviewer-details">
                            <div class="reviewer-name">Mark T.</div>
                            <div class="reviewer-location">Manchester, UK</div>
                        </div>
                        <div class="star-rating">★★★★★</div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span class="verified-badge">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                            Verified Purchase
                        </span>
                    </div>
                    <h4>"Tamed my high-arc sprayer."</h4>
                    <p>My industrial-style faucet looked amazing but sprayed water everywhere. Even washing a single apple soaked the countertop. After adding SmartSplash™, the spray hits the soft wall and drops back into the basin instead of onto my clothes.</p>
                </div>
                
                <!-- Review Card 3 - Jessica with AI-generated portrait -->
                <div class="review-card reveal-on-scroll" style="transition-delay: 0.3s;">
                    <div class="reviewer-info">
                        <div class="reviewer-avatar" style="padding: 0; overflow: hidden;">
                            <img src="reviewer-jessica.png" alt="" width="48" height="48" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;" loading="lazy" decoding="async">
                        </div>
                        <div class="reviewer-details">
                            <div class="reviewer-name">Jessica K.</div>
                            <div class="reviewer-location">Bristol, UK</div>
                        </div>
                        <div class="star-rating">★★★★★</div>
                    </div>
                    <div style="margin-bottom: 12px;">
                        <span class="verified-badge">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>
                            Verified Purchase
                        </span>
                    </div>
                    <h4>"A calmer dishwashing routine."</h4>
                    <p>It's a busy weeknight. I stick SmartSplash™ to the sink edge, scrub vigorously, and let the splashes hit the guard instead of my belly and the floor. When I'm done, I peel it off, rinse it, and I'm finished—no outfit change, no mopping, no drama.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- COMPARISON SECTION - Why SmartSplash™ Beats Ordinary Sink Guards -->
    <section class="comparison-section" style="position: relative;">
        <div class="container">
            <div class="section-header reveal-on-scroll">
                <h2>Why SmartSplash™ Beats Ordinary Sink Guards</h2>
                <p>Not all splash guards are created equal. See how SmartSplash™ compares to standard hard plastic alternatives.</p>
            </div>

            <div class="comparison-table reveal-on-scroll" style="margin-top: 24px; margin-bottom: 8px; max-width: 760px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; background: #FFFFFF; border-radius: 12px; padding: 16px 20px; box-shadow: 0 6px 20px rgba(15,23,42,0.06); border: 1px solid #E5E7EB;">
                    <div style="display: flex; flex-direction: column; gap: 8px; border-right: 1px solid #E5E7EB; padding-right: 16px;">
                        <div style="font-size: 0.8rem; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; color: #DC2626;">Before SmartSplash™</div>
                        <div style="border-radius: 8px; overflow: hidden; background: #FEE2E2; height: 140px; display: flex; align-items: center; justify-content: center; position: relative;">
                            <img src="generated-problem-splash.png" alt="Before SmartSplash - shirt wet and water splashing over the sink edge" style="width: 100%; height: 100%; object-fit: cover; filter: grayscale(25%); opacity: 0.9;">
                            <div style="position: absolute; bottom: 8px; left: 8px; right: 8px; font-size: 0.75rem; font-weight: 500; color: #991B1B; text-shadow: 0 1px 3px rgba(255,255,255,0.8);">Shirt wet, water splashing over the sink edge</div>
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px; padding-left: 16px;">
                        <div style="font-size: 0.8rem; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; color: #059669;">After SmartSplash™</div>
                        <div style="border-radius: 8px; overflow: hidden; background: #ECFEFF; height: 140px; display: flex; align-items: center; justify-content: center; position: relative;">
                            <img src="smartsplash-detail-closeup.png" alt="SmartSplash close-up showing soft flexible silicone, suction cups gripping steel, water beads rolling off surface" style="width: 100%; height: 100%; object-fit: cover;">
                            <div style="position: absolute; bottom: 8px; left: 8px; right: 8px; font-size: 0.75rem; font-weight: 500; color: #065F46; text-shadow: 0 1px 3px rgba(255,255,255,0.9);">Premium silicone with secure suction grip</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="comparison-table">
                <!-- SmartSplash™ Column (Highlighted) -->
                <div class="comparison-column smartsplash reveal-on-scroll">
                    <div class="comparison-column-header">
                        <h4>SmartSplash™</h4>
                        <p>Premium Silicone Guard</p>
                    </div>
                    <ul class="comparison-list">
                        <li>
                            <span class="comparison-icon check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                            </span>
                            Soft, flexible silicone
                        </li>
                        <li>
                            <span class="comparison-icon check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                            </span>
                            Secure suction cups
                        </li>
                        <li>
                            <span class="comparison-icon check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                            </span>
                            Dishwasher safe
                        </li>
                        <li>
                            <span class="comparison-icon check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                            </span>
                            Redirects splashes inward
                        </li>
                        <li>
                            <span class="comparison-icon check">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                            </span>
                            Mold & odor resistant
                        </li>
                    </ul>
                </div>
                
                <!-- Other Guards Column -->
                <div class="comparison-column reveal-on-scroll" style="transition-delay: 0.15s;">
                    <div class="comparison-column-header">
                        <h4>Other Guards</h4>
                        <p>Standard Hard Plastic</p>
                    </div>
                    <ul class="comparison-list">
                        <li>
                            <span class="comparison-icon x">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </span>
                            Hard plastic digs into clothes
                        </li>
                        <li>
                            <span class="comparison-icon x">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </span>
                            Slides or falls off
                        </li>
                        <li>
                            <span class="comparison-icon x">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </span>
                            Must hand-wash only
                        </li>
                        <li>
                            <span class="comparison-icon x">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </span>
                            Water spills onto floor
                        </li>
                        <li>
                            <span class="comparison-icon x">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                            </span>
                            Traps moisture & odors
                        </li>
                    </ul>
                </div>
            </div>
            
            <!-- CTA under comparison -->
            <div style="text-align: center; margin-top: 40px;" class="reveal-on-scroll">
                <a href="#buy-now" class="btn btn-cta" data-analytics-id="cta_comparison_primary">Keep My Shirt Dry — Save 29% Today</a>
            </div>
        </div>
    </section>

    <!-- Wave Separator: Comparison → Product Detail (light gray) - with fade effect -->
    <div class="wave-separator flip fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #F0F4F8;">
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>

    <section id="buy-now" class="product-detail" style="position: relative;" aria-labelledby="product-heading">
        <!-- Decorative cut-off circles - MORE CONTRASTING & MORE OF THEM -->
        <div class="decorative-circle dark-strong" style="width: 300px; height: 300px; top: -5%; left: -120px; clip-path: inset(0 0 0 40%);"></div>
        <div class="decorative-circle dark" style="width: 190px; height: 190px; top: 15%; left: -75px; clip-path: inset(0 0 0 39%);"></div>
        <div class="decorative-circle dark-strong" style="width: 250px; height: 250px; bottom: 15%; right: -95px; clip-path: inset(0 38% 0 0);"></div>
        <div class="decorative-circle dark" style="width: 140px; height: 140px; bottom: 35%; right: -50px; clip-path: inset(0 35% 0 0);"></div>
        <div class="decorative-circle dark" style="width: 160px; height: 160px; top: 50%; right: 8%; clip-path: inset(55% 0 0 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 110px; height: 110px; top: 30%; left: 35%; clip-path: inset(0 0 50% 0);"></div>
        <div class="decorative-circle dark" style="width: 180px; height: 180px; bottom: 50%; left: 20%; clip-path: inset(0 55% 0 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 80px; height: 80px; top: 70%; left: 60%; clip-path: inset(50% 0 0 0);"></div>
        
        <!-- CSS-only decorative accents for Product Detail - subtle, properly-sized visual touches -->
        <div class="css-accent droplet" style="top: 12%; left: 8%; animation-delay: 0.5s;" aria-hidden="true"></div>
        <div class="css-accent badge" style="bottom: 25%; right: 10%; animation-delay: 1s;" aria-hidden="true"></div>
        <div class="css-accent sparkle" style="top: 40%; right: 3%; animation-delay: 2s;" aria-hidden="true"></div>
        <div class="css-accent badge" style="bottom: 45%; left: 5%; animation-delay: 0.8s;" aria-hidden="true"></div>
        
        <div class="container">
            <div class="product-grid">
                <div class="product-gallery">
                    <div class="gallery-main parallax-img" data-parallax-speed="0.02">
                        <img id="mainImage" src="smart-splash-drying-rack.webp.png" alt="SmartSplash Silicone Sink Splash Guard installed behind dishes on a drying rack with a straight back edge along the sink" width="600" height="400" loading="lazy" class="wiggle-img wiggle-delay-4">
                    </div>
                    <div class="gallery-thumbs" role="group" aria-label="Product image gallery">
                        <button type="button" class="thumb active float-x wiggle-delay-1" onclick="changeImage(this, 'smart-splash-drying-rack.webp.png')" aria-label="View SmartSplash installed behind dishes on a drying rack" aria-pressed="true">
                            <img src="smart-splash-drying-rack.webp.png" alt="" loading="lazy">
                        </button>
                        <button type="button" class="thumb float-x wiggle-delay-2" onclick="changeImage(this, 'smart-splash-detail-1.webp')" aria-label="View close-up detail" aria-pressed="false">
                            <img src="smart-splash-detail-1.webp" alt="" loading="lazy">
                        </button>
                        <button type="button" class="thumb float-x wiggle-delay-2" onclick="changeImage(this, 'smart-splash-hero.webp')" aria-label="View hero image" aria-pressed="false">
                            <img src="smart-splash-hero.webp" alt="" loading="lazy">
                        </button>
                        <button type="button" class="thumb float-x wiggle-delay-3" onclick="changeImage(this, 'smart-splash-detail-2.avif')" aria-label="View side angle" aria-pressed="false">
                            <img src="smart-splash-detail-2.avif" alt="" loading="lazy">
                        </button>
                        <button type="button" class="thumb float-x wiggle-delay-4" onclick="changeImage(this, 'smart-splash-lifestyle.png')" aria-label="View lifestyle image" aria-pressed="false">
                            <img src="smart-splash-lifestyle.png" alt="" loading="lazy">
                        </button>
                    </div>
                </div>
                <div class="product-info">
                    <div style="margin-bottom: 10px; color: var(--color-accent); font-weight: 600; letter-spacing: 0.05em;">BEST SELLER</div>
                    <h2 id="product-heading">SmartSplash™ Silicone Sink Splash Guard</h2>
                    <div class="price">
                        <span>$24.99</span>
                        <del>$35.00</del>
                    </div>
                    <div style="font-size: 0.85rem; color: var(--color-text-muted); margin-top: -24px; margin-bottom: 16px;">
                        Ships from the UK · Typical delivery 3–5 working days
                        <br><span style="font-size: 0.8rem; color: var(--color-accent); font-weight: 500;">Designed for busy UK homes with high-pressure taps and shallow sinks.</span>
                    </div>
                    <div style="font-size: 0.85rem; color: var(--color-text-muted); margin-top: -8px; margin-bottom: 16px; display: flex; align-items: center; gap: 6px;">
                        <span style="color: #F59E0B; font-size: 0.9rem;">★★★★★</span>
                        <span>Rated 4.9 by 2,431 UK customers</span>
                    </div>
                    <p style="margin-bottom: 20px; color: var(--color-text-muted);">
                        Tired of finishing the dishes with a soaked shirt and puddles on the floor? SmartSplash™ is a flexible, suction-backed silicone splash guard that attaches to the front edge of your sink to block water before it escapes the basin.
                    </p>
                    <ul class="product-bullets">
                        <li><strong>Instantly stops splashes</strong> from high-arc faucets, sprayers, and shallow sinks.</li>
                        <li><strong>Soft, comfort-first silicone</strong> bends when you lean against it—no sharp edges or bruised bellies.</li>
                        <li><strong>Secure suction grip</strong> keeps it in place on smooth, non-porous rims like granite, quartz, and stainless steel.</li>
                        <li><strong>Easy to clean & mold resistant</strong> thanks to non-porous, heat-resistant silicone that’s dishwasher safe.</li>
                    </ul>
                    <p style="font-size: 0.95rem; color: var(--color-text-main); margin-bottom: 24px; font-weight: 500;">
                        Perfect for high-arc faucets, powerful sprayers, shallow sinks, and busy family kitchens.
                    </p>

                    <!-- Single-variant selector: Akolo White -->
                    <div class="variant-selector" aria-label="Color selection">
                        <div style="font-size: 0.85rem; font-weight: 600; margin-bottom: 8px;">Color</div>
                        <div class="color-options">
                            <button type="button" class="color-opt selected" aria-pressed="true" aria-label="Akolo White" style="background: #F9FAFB; border-color: var(--color-dark);">
                            </button>
                        </div>
                        <div style="font-size: 0.8rem; color: var(--color-text-muted); margin-top: 6px;">
                            Akolo White · a soft matte white that blends cleanly with most stainless steel, ceramic, and composite sinks.
                        </div>
                    </div>
                    
                    <div class="trust-strip" style="margin: 0 0 20px 0; padding: 12px 16px; gap: 16px;">
                        <div class="trust-strip-item" style="font-size: 0.8rem;">
                            <span class="trust-strip-icon" style="width: 16px; height: 16px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle></svg>
                            </span>
                            <span>Free Shipping</span>
                        </div>
                        <div style="width: 1px; height: 12px; background: rgba(0,0,0,0.1); display: inline-block;"></div>
                        <div class="trust-strip-item" style="font-size: 0.8rem;">
                            <span class="trust-strip-icon" style="width: 16px; height: 16px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>
                            </span>
                            <span>30-Day Guarantee</span>
                        </div>
                        <div style="width: 1px; height: 12px; background: rgba(0,0,0,0.1); display: inline-block;"></div>
                        <div class="trust-strip-item" style="font-size: 0.8rem;">
                            <span class="trust-strip-icon" style="width: 16px; height: 16px;">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
                            </span>
                            <span>Secure Checkout</span>
                        </div>
                    </div>

                    <div class="add-to-cart-block">
                        <div id='product-component-1764920785941'></div>
                        <script type="text/javascript">
                        /*<![CDATA[*/
                        (function () {
                          var scriptURL = 'https://sdks.shopifycdn.com/buy-button/latest/buy-button-storefront.min.js';
                          if (window.ShopifyBuy) {
                            if (window.ShopifyBuy.UI) {
                              ShopifyBuyInit();
                            } else {
                              loadScript();
                            }
                          } else {
                            loadScript();
                          }
                          function loadScript() {
                            var script = document.createElement('script');
                            script.async = true;
                            script.src = scriptURL;
                            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(script);
                            script.onload = ShopifyBuyInit;
                          }
                          function ShopifyBuyInit() {
                            var client = ShopifyBuy.buildClient({
                              domain: 'wmddgt-rk.myshopify.com',
                              storefrontAccessToken: '227cc1056e19fe59879e3029c64e558c',
                            });
                            ShopifyBuy.UI.onReady(client).then(function (ui) {
                              ui.createComponent('product', {
                                id: '10525775495495',
                                node: document.getElementById('product-component-1764920785941'),
                                moneyFormat: '%C2%A3%7B%7Bamount%7D%7D',
                                options: {
                          "product": {
                            "styles": {
                              "product": {
                                "@media (min-width: 601px)": {
                                  "max-width": "calc(25% - 20px)",
                                  "margin-left": "20px",
                                  "margin-bottom": "50px"
                                }
                              },
                              "button": {
                                "font-family": "Space Grotesk, sans-serif",
                                "font-weight": "600",
                                "font-size": "1rem",
                                "padding": "16px 32px",
                                "border-radius": "100px",
                                "background": "linear-gradient(135deg, #0F172A, #020617)",
                                "color": "#ffffff",
                                ":hover": {
                                  "background": "#0F172A",
                                  "transform": "translateY(-2px)"
                                }
                              }
                            },
                            "contents": {
                              "img": false,
                              "title": false,
                              "price": false
                            },
                            "text": {
                              "button": "Add to cart"
                            }
                          },
                          "productSet": {
                            "styles": {
                              "products": {
                                "@media (min-width: 601px)": {
                                  "margin-left": "-20px"
                                }
                              }
                            }
                          },
                          "modalProduct": {
                            "contents": {
                              "img": false,
                              "imgWithCarousel": true,
                              "button": false,
                              "buttonWithQuantity": true
                            },
                            "styles": {
                              "product": {
                                "@media (min-width: 601px)": {
                                  "max-width": "100%",
                                  "margin-left": "0px",
                                  "margin-bottom": "0px"
                                }
                              }
                            },
                            "text": {
                              "button": "Add to cart"
                            }
                          },
                          "option": {},
                          "cart": {
                            "text": {
                              "total": "Subtotal",
                              "button": "Checkout"
                            }
                          },
                          "toggle": {}
                        },
                              });
                            });
                          }
                        })();
                        /*]]>*/
                        </script>
                    </div>
                    <div style="margin-top: 12px; font-size: 0.85rem; color: var(--color-text-muted); font-weight: 500; text-align: left;">
                        No outfit change, no mop required.
                    </div>
                </div>
            </div>
            
            <!-- 30-Day Guarantee Banner -->
            <div class="reveal-on-scroll" style="margin-top: 40px;">
                <div class="guarantee-banner">
                    <div class="guarantee-icon">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><polyline points="9 12 12 15 16 10"></polyline></svg>
                    </div>
                    <h3 style="color: white;">30-Day Dry Shirt Guarantee</h3>
                    <p>Try SmartSplash™ risk-free. If you're not completely satisfied with how it keeps your clothes dry and floors safe, return it for a full refund — no questions asked.</p>
                </div>
            </div>
        </div>
    </section>

    <!-- Wave Separator: Product Detail → FAQ (slightly darker gray) - with fade effect -->
    <div class="wave-separator fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #F9FAFB;">
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>

    <section id="faq" class="faq" style="position: relative;" aria-labelledby="faq-heading">
        <!-- Decorative cut-off circles - MORE CONTRASTING & MORE OF THEM -->
        <div class="decorative-circle dark-strong" style="width: 260px; height: 260px; top: -8%; right: -100px; clip-path: inset(0 38% 0 0);"></div>
        <div class="decorative-circle dark" style="width: 150px; height: 150px; top: 18%; right: -55px; clip-path: inset(0 36% 0 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 220px; height: 220px; bottom: 10%; left: -85px; clip-path: inset(0 0 0 38%);"></div>
        <div class="decorative-circle dark" style="width: 120px; height: 120px; bottom: 25%; left: -40px; clip-path: inset(0 0 0 33%);"></div>
        <div class="decorative-circle dark" style="width: 140px; height: 140px; top: 55%; left: 25%; clip-path: inset(0 55% 0 0);"></div>
        <div class="decorative-circle dark-strong" style="width: 100px; height: 100px; top: 35%; left: 50%; clip-path: inset(55% 0 0 0);"></div>
        <div class="decorative-circle dark" style="width: 170px; height: 170px; bottom: 40%; right: 15%; clip-path: inset(0 0 0 50%);"></div>
        <div class="decorative-circle dark-strong" style="width: 90px; height: 90px; top: 75%; right: 30%; clip-path: inset(50% 0 0 0);"></div>
        <div class="container">
            <div class="section-header reveal-on-scroll">
                <h2 id="faq-heading">Frequently Asked Questions</h2>
                <p>Everything you need to know about getting the most out of your SmartSplash™ Silicone Sink Splash Guard.</p>
            </div>
            <div class="faq-grid" role="list">
                <div class="faq-item reveal-on-scroll is-open" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="true" aria-controls="faq-answer-1" onclick="toggleFaq(this)">
                            <span class="faq-question-text">Will this stick to my sink?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-1" class="faq-answer">
                        <p>SmartSplash™ adheres best to smooth, non-porous surfaces like granite, marble, quartz, polished wood, and stainless steel. It may struggle on rough, unsealed stone or heavily textured tiles because the suction cups need a flat surface to seal.</p>
                    </div>
                </div>
                <div class="faq-item reveal-on-scroll" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="false" aria-controls="faq-answer-2" onclick="toggleFaq(this)">
                            <span class="faq-question-text">How do I clean it?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-2" class="faq-answer">
                        <p>Rinse with warm soapy water after use or place it on the top rack of your dishwasher. The silicone is heat-resistant and built for daily use.</p>
                    </div>
                </div>
                <div class="faq-item reveal-on-scroll" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="false" aria-controls="faq-answer-3" onclick="toggleFaq(this)">
                            <span class="faq-question-text">Does it get in the way of my arms?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-3" class="faq-answer">
                        <p>No. The soft, flexible silicone bends comfortably if your arms brush against it—unlike hard plastic guards that dig into your skin.</p>
                    </div>
                </div>
                <div class="faq-item reveal-on-scroll" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="false" aria-controls="faq-answer-4" onclick="toggleFaq(this)">
                            <span class="faq-question-text">Will it mold or start to smell?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-4" class="faq-answer">
                        <p>Silicone is naturally non-porous and resistant to mold and mildew. It doesn't absorb water or odors—just give it a quick rinse periodically.</p>
                    </div>
                </div>
                <div class="faq-item reveal-on-scroll" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="false" aria-controls="faq-answer-5" onclick="toggleFaq(this)">
                            <span class="faq-question-text">What happens if I bump it?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-5" class="faq-answer">
                        <p>The suction cups hold firm against normal bumps. If you hit it hard, it flexes rather than cracks—simply press it back down if any suction releases.</p>
                    </div>
                </div>
                <div class="faq-item reveal-on-scroll" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="false" aria-controls="faq-answer-6" onclick="toggleFaq(this)">
                            <span class="faq-question-text">Can I move it between sinks?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-6" class="faq-answer">
                        <p>Yes! Peel up one edge to release the seal, move it to another sink, and press down again. Perfect for kitchen, laundry, or utility sinks.</p>
                    </div>
                </div>
                <div class="faq-item reveal-on-scroll" role="listitem">
                    <h3>
                        <button class="faq-question" aria-expanded="false" aria-controls="faq-answer-7" onclick="toggleFaq(this)">
                            <span class="faq-question-text">Is it safe for kids and families?</span>
                            <span class="faq-icon" aria-hidden="true">+</span>
                        </button>
                    </h3>
                    <div id="faq-answer-7" class="faq-answer">
                        <p>Absolutely. The soft silicone has no sharp edges, making it safe for little helpers learning to wash dishes—and it reduces slippery floor puddles.</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- Wave Separator: FAQ → Footer - with fade effect -->
    <div class="wave-separator flip fade-both">
        <svg viewBox="0 0 1200 120" preserveAspectRatio="none" style="fill: #E5E7EB;">
            <path d="M0,0V46.29c47.79,22.2,103.59,32.17,158,28,70.36-5.37,136.33-33.31,206.8-37.5C438.64,32.43,512.34,53.67,583,72.05c69.27,18,138.3,24.88,209.4,13.08,36.15-6,69.85-17.84,104.45-29.34C989.49,25,1113-14.29,1200,52.47V120H0Z" opacity=".25"></path>
            <path d="M0,0V15.81C13,36.92,27.64,56.86,47.69,72.05,99.41,111.27,165,111,224.58,91.58c31.15-10.15,60.09-26.07,89.67-39.8,40.92-19,84.73-46,130.83-49.67,36.26-2.85,70.9,9.42,98.6,31.56,31.77,25.39,62.32,62,103.63,73,40.44,10.79,81.35-6.69,119.13-24.28s75.16-39,116.92-43.05c59.73-5.85,113.28,22.88,168.9,38.84,30.2,8.66,59,6.17,87.09-7.5,22.43-10.89,48-26.93,60.65-49.24V120H0Z" opacity=".5"></path>
            <path d="M0,0V5.63C149.93,59,314.09,71.32,475.83,42.57c43-7.64,84.23-20.12,127.61-26.46,59-8.63,112.48,12.24,165.56,35.4C827.93,77.22,886,95.24,951.2,90c86.53-7,172.46-45.71,248.8-84.81V120H0Z"></path>
        </svg>
    </div>
    </main>

    <footer role="contentinfo" style="background: linear-gradient(to bottom, #F3F4F6, #E5E7EB); padding: 80px 0 40px; margin-top: 0; position: relative; overflow: hidden;">
        <!-- Subtle footer decoration -->
        <div class="decorative-circle dark" style="width: 300px; height: 300px; top: -150px; left: 50%; transform: translateX(-50%); opacity: 0.05;"></div>
        
        <div class="container" style="text-align: center; color: var(--color-text-muted); position: relative; z-index: 1;">
            <div style="font-family: var(--font-heading); font-weight: 700; font-size: 1.5rem; color: var(--color-dark); margin-bottom: 16px;">SmartSplash™</div>
            <div style="display: flex; justify-content: center; gap: 24px; margin-bottom: 32px; font-size: 0.9rem;">
                <a href="#" class="footer-link" data-analytics-id="footer_privacy">Privacy Policy</a>
                <a href="#" class="footer-link" data-analytics-id="footer_terms">Terms of Service</a>
                <a href="#" class="footer-link" data-analytics-id="footer_contact">Contact Support</a>
            </div>
            <p style="font-size: 0.85rem; opacity: 0.7;">&copy; 2025 SmartSplash™. Designed for dry shirts everywhere.</p>
        </div>
    </footer>

    <!-- Mobile sticky CTA bar (shown via JS on scroll) -->
    <div class="mobile-cta-bar" id="mobileCtaBar" aria-hidden="true">
        <div class="mobile-cta-bar__info">
            <span class="mobile-cta-bar__title">SmartSplash™ · $24.99 · Free Shipping</span>
            <span class="mobile-cta-bar__subtitle">30-Day Dry Shirt Guarantee</span>
        </div>
        <a href="#buy-now" class="btn btn-cta mobile-cta-bar__btn">
            Keep My Shirt Dry
        </a>
    </div>

    <!-- Desktop sticky bottom bar (shown on scroll past hero) -->
    <div class="desktop-cta-bar" id="desktopCtaBar" aria-hidden="true">
        <div class="desktop-cta-bar__content container">
            <div class="desktop-cta-bar__info">
                <span class="desktop-cta-bar__title">SmartSplash™</span>
                <span class="desktop-cta-bar__divider">·</span>
                <span class="desktop-cta-bar__price">$24.99</span>
                <span class="desktop-cta-bar__divider">·</span>
                <span class="desktop-cta-bar__benefit">Free Shipping</span>
                <span class="desktop-cta-bar__divider">·</span>
                <span class="desktop-cta-bar__benefit">30-Day Dry Shirt Guarantee</span>
            </div>
            <a href="#buy-now" class="btn btn-cta desktop-cta-bar__btn">
                Keep My Shirt Dry
            </a>
        </div>
    </div>

    <script>
        // Detect reduced motion preference safely
        const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // Cache commonly used elements
        const revealElements = document.querySelectorAll('.reveal-on-scroll');
        const stepProgress = document.getElementById('stepProgress');
        const stepItems = document.querySelectorAll('.step-item');

        // Scroll Reveal Animation with reduced-motion support & progress bar integration
        if (!prefersReducedMotion && 'IntersectionObserver' in window) {
            const observerOptions = {
                threshold: 0.1,
                rootMargin: "0px 0px -50px 0px"
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('is-visible');

                        // Progressive "How It Works" line animation
                        if (entry.target.classList.contains('step-item') && stepProgress && stepItems.length) {
                            const index = Array.from(stepItems).indexOf(entry.target);
                            if (index !== -1) {
                                const progressPercent = ((index + 1) / stepItems.length) * 100;
                                stepProgress.style.width = progressPercent + '%';
                            }
                        }

                        // Unobserve element once it's visible for performance
                        observer.unobserve(entry.target);
                    }
                });
            }, observerOptions);

            revealElements.forEach(el => {
                observer.observe(el);
            });
        } else {
            // If reduced motion is preferred or IntersectionObserver is not available:
            // - Make all reveal elements visible immediately
            // - Fill the "How It Works" progress bar
            revealElements.forEach(el => el.classList.add('is-visible'));
            if (stepProgress) {
                stepProgress.style.width = '100%';
            }
        }

        // Header Scroll Effect
        window.addEventListener('scroll', () => {
            const header = document.getElementById('header');
            if (!header) return;

            if (window.scrollY > 50) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }
        });

        // Mobile Menu Toggle
        const mobileMenuToggle = document.getElementById('mobileMenuToggle');
        const mainNav = document.getElementById('mainNav');
        
        if (mobileMenuToggle && mainNav) {
            mobileMenuToggle.addEventListener('click', () => {
                const isExpanded = mobileMenuToggle.getAttribute('aria-expanded') === 'true';
                mobileMenuToggle.setAttribute('aria-expanded', !isExpanded);
                mainNav.classList.toggle('is-open');
                
                // Prevent body scroll when menu is open
                document.body.style.overflow = isExpanded ? '' : 'hidden';
            });
            
            // Close menu when clicking a nav link
            mainNav.querySelectorAll('a').forEach(link => {
                link.addEventListener('click', () => {
                    mobileMenuToggle.setAttribute('aria-expanded', 'false');
                    mainNav.classList.remove('is-open');
                    document.body.style.overflow = '';
                });
            });
            
            // Close menu on escape key
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && mainNav.classList.contains('is-open')) {
                    mobileMenuToggle.setAttribute('aria-expanded', 'false');
                    mainNav.classList.remove('is-open');
                    document.body.style.overflow = '';
                    mobileMenuToggle.focus();
                }
            });
        }

        // Smooth-scrolling for in-page anchor links (respects reduced motion)
        if (!prefersReducedMotion) {
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', (event) => {
                    const targetId = anchor.getAttribute('href').slice(1);
                    const target = document.getElementById(targetId);

                    if (target) {
                        event.preventDefault();
                        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
        }

        // FAQ Accordion Toggle Function
        function toggleFaq(button) {
            const faqItem = button.closest('.faq-item');
            const isOpen = faqItem.classList.contains('is-open');
            
            // Close all other FAQ items (optional - remove if you want multiple open)
            document.querySelectorAll('.faq-item.is-open').forEach(item => {
                if (item !== faqItem) {
                    item.classList.remove('is-open');
                    item.querySelector('.faq-question').setAttribute('aria-expanded', 'false');
                }
            });
            
            // Toggle current item
            if (isOpen) {
                faqItem.classList.remove('is-open');
                button.setAttribute('aria-expanded', 'false');
            } else {
                faqItem.classList.add('is-open');
                button.setAttribute('aria-expanded', 'true');
            }
        }

        // Keyboard support for FAQ
        document.querySelectorAll('.faq-question').forEach(button => {
            button.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    toggleFaq(button);
                }
            });
        });

        // Image Gallery with smooth fade transition and SPLASH EFFECT
        function changeImage(thumb, src) {
            const mainImage = document.getElementById('mainImage');
            const galleryMain = document.querySelector('.gallery-main');
            if (!mainImage || !src) return;

            // Avoid unnecessary work if image is already shown
            if (mainImage.getAttribute('src') === src) return;

            // Update active thumbnail state and aria-pressed
            document.querySelectorAll('.thumb').forEach(t => {
                t.classList.remove('active');
                t.setAttribute('aria-pressed', 'false');
            });
            thumb.classList.add('active');
            thumb.setAttribute('aria-pressed', 'true');

            // Update main image alt text based on which thumbnail was clicked
            const altTexts = {
                'smart-splash-drying-rack.webp.png': 'SmartSplash Silicone Sink Splash Guard installed behind dishes on a drying rack with a straight back edge along the sink',
                'smart-splash-solution.webp': 'SmartSplash Silicone Sink Splash Guard - main product view showing flexible silicone design',
                'smart-splash-detail-1.webp': 'SmartSplash close-up detail showing suction cups and silicone texture',
                'smart-splash-hero.webp': 'SmartSplash installed on a modern kitchen sink',
                'smart-splash-detail-2.avif': 'SmartSplash side angle view showing curved splash barrier',
                'smart-splash-lifestyle.png': 'SmartSplash in use - keeping clothes dry while doing dishes'
            };
            mainImage.alt = altTexts[src] || 'SmartSplash product image';

            if (prefersReducedMotion) {
                // Instant swap if user prefers reduced motion
                mainImage.src = src;
                return;
            }

            // =============================================
            // SUBTLE WATER SPLASH EFFECT - Clean, understated transition
            // =============================================
            if (galleryMain) {
                // Create container if needed
                let splashContainer = galleryMain.querySelector('.splash-container');
                if (!splashContainer) {
                    splashContainer = document.createElement('div');
                    splashContainer.className = 'splash-container';
                    galleryMain.appendChild(splashContainer);
                }

                const rect = galleryMain.getBoundingClientRect();
                
                // ========== SUBTLE DROPLETS - Small, few, quick fade ==========
                const dropletCount = 12; // Much fewer droplets
                
                for (let i = 0; i < dropletCount; i++) {
                    const droplet = document.createElement('div');
                    droplet.className = 'water-droplet';
                    
                    // Random edge selection
                    const edge = Math.floor(Math.random() * 4);
                    const posOnEdge = Math.random();
                    
                    let startX, startY, baseVelX, baseVelY;
                    
                    if (edge === 0) { // Top edge
                        startX = rect.width * posOnEdge;
                        startY = 0;
                        baseVelX = (Math.random() - 0.5) * 2;
                        baseVelY = -(2 + Math.random() * 3);
                    } else if (edge === 1) { // Right edge
                        startX = rect.width;
                        startY = rect.height * posOnEdge;
                        baseVelX = 2 + Math.random() * 3;
                        baseVelY = (Math.random() - 0.5) * 2;
                    } else if (edge === 2) { // Bottom edge
                        startX = rect.width * posOnEdge;
                        startY = rect.height;
                        baseVelX = (Math.random() - 0.5) * 2;
                        baseVelY = 2 + Math.random() * 3;
                    } else { // Left edge
                        startX = 0;
                        startY = rect.height * posOnEdge;
                        baseVelX = -(2 + Math.random() * 3);
                        baseVelY = (Math.random() - 0.5) * 2;
                    }
                    
                    // Small sizes only (3-8px)
                    const size = 3 + Math.random() * 5;
                    
                    droplet.style.width = size + 'px';
                    droplet.style.height = size + 'px';
                    droplet.style.left = startX + 'px';
                    droplet.style.top = startY + 'px';
                    droplet.style.opacity = '0.6';
                    
                    splashContainer.appendChild(droplet);
                    
                    // Subtle physics animation
                    let x = startX, y = startY;
                    let vx = baseVelX, vy = baseVelY;
                    let life = 0;
                    const maxLife = 30 + Math.random() * 20; // Short lifespan
                    const friction = 0.94;
                    const gravity = 0.15;
                    
                    function animateDroplet() {
                        life++;
                        
                        vx *= friction;
                        vy *= friction;
                        vy += gravity;
                        x += vx;
                        y += vy;
                        
                        const progress = life / maxLife;
                        const opacity = Math.max(0, 0.6 * (1 - Math.pow(progress, 0.4)));
                        const scale = 1 - (progress * 0.3);
                        
                        droplet.style.left = x + 'px';
                        droplet.style.top = y + 'px';
                        droplet.style.opacity = opacity;
                        droplet.style.transform = `scale(${scale})`;
                        
                        if (life < maxLife && opacity > 0.01) {
                            requestAnimationFrame(animateDroplet);
                        } else {
                            droplet.remove();
                        }
                    }
                    
                    setTimeout(() => requestAnimationFrame(animateDroplet), Math.random() * 30);
                }
                
                // ========== SINGLE SUBTLE RING at center ==========
                const ring = document.createElement('div');
                ring.className = 'splash-ring';
                
                ring.style.left = (rect.width / 2) + 'px';
                ring.style.top = (rect.height / 2) + 'px';
                ring.style.width = '20px';
                ring.style.height = '20px';
                ring.style.transform = 'translate(-50%, -50%)';
                ring.style.opacity = '0.4';
                
                splashContainer.appendChild(ring);
                
                let ringSize = 20;
                let ringOpacity = 0.4;
                let ringLife = 0;
                const ringMaxLife = 25;
                
                function animateRing() {
                    ringLife++;
                    ringSize += 6;
                    ringOpacity = 0.4 * (1 - ringLife / ringMaxLife);
                    
                    ring.style.width = ringSize + 'px';
                    ring.style.height = ringSize + 'px';
                    ring.style.opacity = ringOpacity;
                    
                    if (ringLife < ringMaxLife) {
                        requestAnimationFrame(animateRing);
                    } else {
                        ring.remove();
                    }
                }
                
                requestAnimationFrame(animateRing);
            }

            // Animate fade-out, swap src, then fade-in
            mainImage.classList.remove('is-fading-in');
            mainImage.classList.add('is-fading-out');

            setTimeout(() => {
                mainImage.src = src;
                mainImage.classList.remove('is-fading-out');
                mainImage.classList.add('is-fading-in');

                // Clean up the class after the fade-in completes
                setTimeout(() => {
                    mainImage.classList.remove('is-fading-in');
                }, 120);
            }, 80); // Faster image swap
        }

        // ========================================
        // PARTICLE SYSTEM - Mouse Trail Effect
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const canvas = document.getElementById('particleCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            let particles = [];
            let mouseX = 0;
            let mouseY = 0;
            let isMouseMoving = false;
            let mouseTimeout;

            // Resize canvas to full window
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Particle class
            class Particle {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    // SMALLER particles on average (0.5-2px) with more variation
                    this.size = Math.random() * 1.5 + 0.5;
                    this.speedX = (Math.random() - 0.5) * 1.5; // Slower speed
                    this.speedY = (Math.random() - 0.5) * 1.5;
                    this.life = 1;
                    this.decay = Math.random() * 0.025 + 0.015; // Faster decay for smaller particles
                    // VARIED COLORS - spread across teal, cyan, blue, and occasional purple
                    // Random selection from color palette
                    const colorChoice = Math.random();
                    if (colorChoice < 0.4) {
                        // Deep teal (most common)
                        this.hue = 180 + Math.random() * 15;
                    } else if (colorChoice < 0.65) {
                        // Cyan/aqua
                        this.hue = 195 + Math.random() * 10;
                    } else if (colorChoice < 0.85) {
                        // Blue
                        this.hue = 210 + Math.random() * 20;
                    } else {
                        // Occasional purple accent
                        this.hue = 260 + Math.random() * 30;
                    }
                    // Also vary saturation and lightness slightly
                    this.saturation = 70 + Math.random() * 30; // 70-100%
                    this.lightness = 40 + Math.random() * 20; // 40-60%
                }

                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.life -= this.decay;
                    this.size *= 0.95;
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    // Use varied saturation and lightness for more natural look
                    ctx.fillStyle = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.life * 0.6})`;
                    ctx.fill();
                    
                    // Subtle glow matching particle color
                    ctx.shadowBlur = 6 + (this.size * 2);
                    ctx.shadowColor = `hsla(${this.hue}, ${this.saturation}%, ${this.lightness}%, ${this.life * 0.25})`;
                }
            }

            // Track mouse movement
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                isMouseMoving = true;

                // Create fewer particles on mouse move
                if (Math.random() > 0.5) { // Only create particle 50% of the time for sparser trail
                    particles.push(new Particle(mouseX, mouseY));
                }

                // Clear timeout and set new one
                clearTimeout(mouseTimeout);
                mouseTimeout = setTimeout(() => {
                    isMouseMoving = false;
                }, 100);
            });

            // CLICK EXPLOSION EFFECT
            document.addEventListener('mousedown', (e) => {
                const burstCount = 10; // Slightly fewer particles
                for (let i = 0; i < burstCount; i++) {
                    const p = new Particle(e.clientX, e.clientY);
                    
                    // Explosion physics: faster speed, random direction
                    const angle = Math.random() * Math.PI * 2;
                    const velocity = Math.random() * 3.5 + 1.5; // Speed 1.5-5
                    
                    p.speedX = Math.cos(angle) * velocity;
                    p.speedY = Math.sin(angle) * velocity;
                    
                    // Varied colors for explosion too
                    const explosionColorChoice = Math.random();
                    if (explosionColorChoice < 0.5) {
                        p.hue = 190 + Math.random() * 20; // Teal/cyan
                    } else if (explosionColorChoice < 0.8) {
                        p.hue = 220 + Math.random() * 20; // Blue
                    } else {
                        p.hue = 270 + Math.random() * 30; // Purple
                    }
                    
                    // Smaller explosion particles (1-3px instead of 2-5px)
                    p.size = Math.random() * 2 + 1;
                    
                    particles.push(p);
                }
            });

            // Animation loop
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Update and draw particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    particles[i].draw();

                    // Remove dead particles
                    if (particles[i].life <= 0 || particles[i].size <= 0.5) {
                        particles.splice(i, 1);
                    }
                }

                // Limit max particles for performance
                if (particles.length > 150) {
                    particles.splice(0, particles.length - 150);
                }

                requestAnimationFrame(animate);
            }
            animate();
        })();

        // ========================================
        // PARALLAX SCROLLING - "Sliding Planes" Effect
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            // Target both images and text for that "Apple-style" depth
            const parallaxElements = document.querySelectorAll('.parallax-img, .parallax-text');
            if (!parallaxElements.length) return;

            let ticking = false;

            function updateParallax() {
                const scrollY = window.scrollY;
                const windowHeight = window.innerHeight;

                parallaxElements.forEach(el => {
                    // Get speed from data attribute, default to 0 if not set
                    const speed = parseFloat(el.dataset.parallaxSpeed) || 0;
                    if (speed === 0) return;

                    const rect = el.getBoundingClientRect();
                    // We calculate position relative to the viewport center
                    // This ensures the element is at its "natural" position when in the center of the screen
                    const elementCenter = rect.top + (rect.height / 2);
                    const viewportCenter = windowHeight / 2;
                    
                    const distanceFromCenter = elementCenter - viewportCenter;

                    // Apply parallax transform
                    // Negative speed moves against scroll (slower), Positive moves with scroll (faster)
                    const translateY = distanceFromCenter * speed;
                    
                    // Only apply rotation to images, not text
                    let transformString = `translateY(${translateY}px)`;
                    
                    if (el.classList.contains('parallax-img')) {
                         // Subtle rotation for images only
                         const rotation = (distanceFromCenter / windowHeight) * 1.5;
                         transformString += ` rotate(${rotation}deg)`;
                    }

                    el.style.transform = transformString;
                });

                ticking = false;
            }

            window.addEventListener('scroll', () => {
                if (!ticking) {
                    requestAnimationFrame(updateParallax);
                    ticking = true;
                }
            });

            // Initial call
            updateParallax();
        })();

        // ========================================
        // POSITIONAL FLOATING - Images float based on vertical position
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const floatingImages = document.querySelectorAll('.wiggle-img, .float-y, .float-x');
            if (!floatingImages.length) return;

            // Add unique offsets based on element position
            floatingImages.forEach((img, index) => {
                const rect = img.getBoundingClientRect();
                const pagePosition = rect.top / document.documentElement.scrollHeight;
                
                // Adjust animation duration and delay based on position
                const baseDuration = 4 + (pagePosition * 3); // 4-7 seconds
                const delay = (index * 0.3) % 2; // Staggered delays
                
                img.style.animationDuration = `${baseDuration}s`;
                img.style.animationDelay = `-${delay}s`;
            });

            // Update floating intensity based on scroll position
            let floatTicking = false;

            function updateFloating() {
                const scrollY = window.scrollY;
                const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
                const scrollProgress = scrollY / maxScroll;

                floatingImages.forEach((img, index) => {
                    const rect = img.getBoundingClientRect();
                    const isInView = rect.top < window.innerHeight && rect.bottom > 0;

                    if (isInView) {
                        // Increase animation intensity as user scrolls deeper
                        const intensity = 1 + (scrollProgress * 0.5);
                        const verticalOffset = Math.sin((scrollY / 200) + index) * 3 * intensity;
                        
                        // Apply subtle additional transform
                        const currentTransform = img.style.transform || '';
                        if (!currentTransform.includes('translateY')) {
                            img.style.setProperty('--float-offset', `${verticalOffset}px`);
                        }
                    }
                });

                floatTicking = false;
            }

            window.addEventListener('scroll', () => {
                if (!floatTicking) {
                    requestAnimationFrame(updateFloating);
                    floatTicking = true;
                }
            });
        })();

        // ========================================
        // MOUSE INTERACTION - Images, Steps & Mercury Text
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            // --- SETUP MERCURY TEXT ---
            // Wrap text content of headings and key paragraphs in spans to isolate transform
            const textTargets = document.querySelectorAll('h1, h2, h3, .hero-text p, .comp-header p');
            const mercuryElements = [];

            textTargets.forEach(el => {
                // Skip if already processed or has complex children
                if (el.querySelector('.mercury-span') || el.children.length > 0) return;
                
                const originalText = el.innerText;
                el.innerHTML = `<span class="mercury-span">${originalText}</span>`;
                const span = el.querySelector('.mercury-span');
                
                // Store original color for interpolation
                const computedStyle = window.getComputedStyle(el);
                const color = computedStyle.color; // e.g. "rgb(100, 100, 100)"
                
                mercuryElements.push({
                    el: span,
                    baseColor: color,
                    x: 0, // Current physics position
                    y: 0,
                    vx: 0, // Velocity
                    vy: 0,
                    targetX: 0,
                    targetY: 0
                });
            });

            const interactiveImages = document.querySelectorAll('.hero-image-wrapper img, .comp-img img, .gallery-main img');
            const stepNumbers = document.querySelectorAll('.step-number');
            
            // Mouse State
            let mouseX = 0;
            let mouseY = 0;
            let mouseVX = 0; // Mouse Velocity X
            let mouseVY = 0; // Mouse Velocity Y
            let lastMouseX = 0;
            let lastMouseY = 0;

            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                
                // Calculate mouse velocity (simple difference)
                mouseVX = mouseX - lastMouseX;
                mouseVY = mouseY - lastMouseY;
                
                lastMouseX = mouseX;
                lastMouseY = mouseY;

                // 1. Image Tilt/Move Effect - DISABLED
                // This was causing too much movement and conflicting with the 3D tilt effect
                // The 3D tilt in the IMAGE HOVER section handles this more subtly now
                /*
                interactiveImages.forEach(img => {
                    const rect = img.getBoundingClientRect();
                    const imgCenterX = rect.left + rect.width / 2;
                    const imgCenterY = rect.top + rect.height / 2;
                    
                    const distanceX = e.clientX - imgCenterX;
                    const distanceY = e.clientY - imgCenterY;
                    const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
                    
                    const maxDistance = 500;
                    if (distance < maxDistance) {
                        const strength = (1 - distance / maxDistance) * 0.025;
                        const moveX = distanceX * strength;
                        const moveY = distanceY * strength;
                        img.style.transform = `translate(${moveX}px, ${moveY}px) scale(${1 + strength})`;
                    } else {
                        img.style.transform = '';
                    }
                });
                */

                // 2. Step Number Glow Effect (Direct Response)
                stepNumbers.forEach(step => {
                    const rect = step.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const dist = Math.hypot(e.clientX - centerX, e.clientY - centerY);
                    const maxDist = 250;
                    
                    if (dist < maxDist) {
                        const intensity = 1 - (dist / maxDist);
                        const scale = 1 + (intensity * 0.15);
                        step.style.setProperty('--glow-opacity', intensity.toFixed(2));
                        step.style.transform = `scale(${scale})`;
                        step.style.borderColor = `rgba(8, 145, 178, ${0.5 + (intensity * 0.5)})`;
                    } else {
                        step.style.setProperty('--glow-opacity', '0');
                        step.style.transform = 'scale(1)';
                        step.style.borderColor = '';
                    }
                });
            });

            // 3. Mercury Text Physics Loop (Runs every frame for smoothness)
            function animateMercury() {
                const time = Date.now() * 0.002; // Time factor for orbit
                
                mercuryElements.forEach(item => {
                    const rect = item.el.getBoundingClientRect();
                    // Skip if off screen
                    if (rect.bottom < 0 || rect.top > window.innerHeight) return;

                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    
                    const dx = mouseX - centerX;
                    const dy = mouseY - centerY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = 400; // Interaction radius

                    // --- A. COLOR DARKENING ---
                    if (dist < maxDist) {
                        // Calculate darkness factor (0 = original, 1 = black)
                        // We want it to get darker as we get closer
                        const darkness = Math.pow(1 - (dist / maxDist), 2); // Quadratic falloff for smoothness
                        
                        // Simple approach: Mix original color with black
                        // Assuming original is roughly grey/dark grey, we just darken it.
                        // For a robust solution without parsing RGB, we can use text-shadow or filter
                        // But filter:brightness is easiest
                        const brightness = 1 - (darkness * 0.8); // Go down to 20% brightness
                        item.el.style.filter = `brightness(${brightness})`;
                        // Also slight scale up
                        // item.el.style.letterSpacing = `${-0.02 + (darkness * 0.01)}em`;
                    } else {
                        item.el.style.filter = 'brightness(1)';
                    }

                    // --- B. MOTION (Orbit + Sway) ---
                    
                    // 1. Idle Circular Motion (The "Orbit")
                    // Small radius (2px), slow speed
                    const orbitX = Math.sin(time + rect.top) * 2;
                    const orbitY = Math.cos(time + rect.top) * 2;

                    // 2. Velocity Sway (The "Mercury Blob")
                    // If mouse is close and moving fast, pull the text
                    let swayForceX = 0;
                    let swayForceY = 0;

                    if (dist < maxDist) {
                        // The "Blob" effect:
                        // If moving quickly, the text should "drag" or "lag" behind slightly,
                        // or "bulge" towards the movement.
                        // Let's make it "magnetic" but fluid.
                        
                        const velocityInfluence = 0.15; // How much mouse speed affects it
                        const proximityInfluence = 1 - (dist / maxDist);
                        
                        // Add mouse velocity to target position (creates the sway/drag)
                        swayForceX = mouseVX * velocityInfluence * proximityInfluence;
                        swayForceY = mouseVY * velocityInfluence * proximityInfluence;
                    }

                    // Physics: Spring to target
                    // Target is Orbit + Sway
                    const targetX = orbitX + swayForceX;
                    const targetY = orbitY + swayForceY;

                    // Lerp current position to target (Elasticity)
                    // Lower factor = more "heavy/mercury" feel (0.05 - 0.1)
                    item.x += (targetX - item.x) * 0.08;
                    item.y += (targetY - item.y) * 0.08;

                    item.el.style.transform = `translate(${item.x}px, ${item.y}px)`;
                });

                // Decay mouse velocity (friction) so sway settles
                mouseVX *= 0.9;
                mouseVY *= 0.9;

                requestAnimationFrame(animateMercury);
            }
            
            animateMercury();

        })();
        // ========================================
        // MERCURY BLOB CURSOR - Physics-based water droplet with satellites
        // ========================================
        (function() {
            if (prefersReducedMotion) return;
            
            const orb = document.getElementById('mercuryOrb');
            const satelliteEls = document.querySelectorAll('.satellite-droplet');
            if (!orb) return;

            // Main blob physics state
            let orbX = window.innerWidth / 2;
            let orbY = window.innerHeight / 2;
            let orbVX = 0;
            let orbVY = 0;
            let targetX = orbX;
            let targetY = orbY;
            let isVisible = false;

            // WEAKER SPRING = more slosh, more floaty
            const SPRING = 0.045;      // Weaker pull (was 0.08)
            const FRICTION = 0.82;     // More slippery (was 0.75)
            const VELOCITY_SCALE = 0.5; // More stretch (was 0.35)

            // Satellite droplet physics - each has its own state
            const satellites = [];
            satelliteEls.forEach((el, i) => {
                satellites.push({
                    el: el,
                    x: 0,
                    y: 0,
                    vx: 0,
                    vy: 0,
                    // Each satellite has different physics (weaker connection)
                    spring: 0.02 + (i * 0.008),  // 0.02, 0.028, 0.036
                    friction: 0.88 - (i * 0.02), // 0.88, 0.86, 0.84
                    offset: (i + 1) * 120,       // Angle offset for orbit
                    orbitRadius: 8 + (i * 4),    // Distance from main blob
                    active: false
                });
            });

            // Track mouse velocity
            let lastMouseX = 0;
            let lastMouseY = 0;
            let mouseSpeed = 0;

            document.addEventListener('mousemove', (e) => {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                mouseSpeed = Math.sqrt(dx * dx + dy * dy);
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;

                targetX = e.clientX;
                targetY = e.clientY;
                
                if (!isVisible) {
                    isVisible = true;
                    orbX = e.clientX;
                    orbY = e.clientY;
                    orb.classList.add('is-visible');
                    // Initialize satellites at orb position
                    satellites.forEach(s => {
                        s.x = orbX;
                        s.y = orbY;
                    });
                }
            });

            document.addEventListener('mouseleave', () => {
                isVisible = false;
                orb.classList.remove('is-visible');
                satellites.forEach(s => {
                    s.active = false;
                    s.el.classList.remove('is-active');
                });
            });

            // Main animation loop
            let time = 0;
            function animateBlob() {
                time += 0.03;

                // === MAIN BLOB PHYSICS ===
                const dx = targetX - orbX;
                const dy = targetY - orbY;
                
                orbVX += dx * SPRING;
                orbVY += dy * SPRING;
                orbVX *= FRICTION;
                orbVY *= FRICTION;
                orbX += orbVX;
                orbY += orbVY;

                const speed = Math.sqrt(orbVX * orbVX + orbVY * orbVY);
                const angle = Math.atan2(orbVY, orbVX) * (180 / Math.PI);
                
                // More pronounced stretch
                const stretchAmount = Math.min(speed * VELOCITY_SCALE, 2);
                const scaleX = 1 + stretchAmount * 0.5;
                const scaleY = 1 - stretchAmount * 0.2;
                
                const minSpeed = 0.3;
                const finalScaleX = speed > minSpeed ? scaleX : 1 + (scaleX - 1) * (speed / minSpeed);
                const finalScaleY = speed > minSpeed ? scaleY : 1 + (scaleY - 1) * (speed / minSpeed);

                orb.style.left = orbX + 'px';
                orb.style.top = orbY + 'px';
                orb.style.transform = `translate(-50%, -50%) rotate(${angle}deg) scale(${finalScaleX}, ${finalScaleY})`;

                // === SATELLITE DROPLET PHYSICS ===
                satellites.forEach((sat, i) => {
                    // Satellites become active when moving fast enough
                    const activationThreshold = 3 + (i * 2); // First activates easiest
                    
                    if (speed > activationThreshold && !sat.active) {
                        sat.active = true;
                        sat.el.classList.add('is-active');
                        // Launch satellite from current orb position with some inherited velocity
                        sat.x = orbX;
                        sat.y = orbY;
                        sat.vx = orbVX * (0.8 - i * 0.15);
                        sat.vy = orbVY * (0.8 - i * 0.15);
                    }
                    
                    if (sat.active) {
                        // Satellites orbit around the main blob with their own physics
                        // They're pulled to a point that orbits around the main blob
                        const orbitAngle = time * (1.5 - i * 0.3) + sat.offset * (Math.PI / 180);
                        const targetSatX = orbX + Math.cos(orbitAngle) * sat.orbitRadius;
                        const targetSatY = orbY + Math.sin(orbitAngle) * sat.orbitRadius;
                        
                        // VERY weak spring - they float loosely
                        const satDx = targetSatX - sat.x;
                        const satDy = targetSatY - sat.y;
                        
                        sat.vx += satDx * sat.spring;
                        sat.vy += satDy * sat.spring;
                        sat.vx *= sat.friction;
                        sat.vy *= sat.friction;
                        sat.x += sat.vx;
                        sat.y += sat.vy;

                        // Position and slight scale based on velocity
                        const satSpeed = Math.sqrt(sat.vx * sat.vx + sat.vy * sat.vy);
                        const satScale = 1 + Math.min(satSpeed * 0.1, 0.5);
                        
                        sat.el.style.left = sat.x + 'px';
                        sat.el.style.top = sat.y + 'px';
                        sat.el.style.transform = `translate(-50%, -50%) scale(${satScale})`;

                        // Deactivate if main blob is slow and satellite is close
                        if (speed < 1 && Math.abs(satDx) < 5 && Math.abs(satDy) < 5) {
                            sat.active = false;
                            sat.el.classList.remove('is-active');
                        }
                    }
                });

                requestAnimationFrame(animateBlob);
            }
            
            animateBlob();
        })();

        // ========================================
        // COMPARISON CARDS - Gradual Differential Parallax & Section Blur
        // Uses continuous RAF loop to work with Mac momentum scrolling
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const problemSolutionSection = document.querySelector('.problem-solution');
            const compCards = document.querySelectorAll('.comp-card');
            if (!compCards.length || !problemSolutionSection) return;

            // Track current animated positions for smooth interpolation
            let currentOffsets = [0, 0];
            let lastScrollY = window.scrollY;

            function updateCompCards() {
                const windowHeight = window.innerHeight;
                const scrollY = window.scrollY;
                const sectionRect = problemSolutionSection.getBoundingClientRect();
                
                // Get the section's position relative to document
                const sectionTop = sectionRect.top + scrollY;
                const sectionHeight = sectionRect.height;
                
                // Calculate total scroll distance for the effect
                // Start when section is 1.5 viewport heights away (very early)
                // End when section has scrolled 1 viewport height past
                const effectStart = sectionTop - (windowHeight * 1.5);
                const effectEnd = sectionTop + sectionHeight + (windowHeight * 0.5);
                const effectRange = effectEnd - effectStart;
                
                // Calculate progress through this range (0 = just starting, 1 = finished)
                const scrollProgress = (scrollY - effectStart) / effectRange;
                const clampedProgress = Math.min(Math.max(scrollProgress, 0), 1);

                // Apply subtle blur to entire section when scrolling far from center
                const windowCenter = windowHeight / 2;
                const sectionCenter = sectionRect.top + sectionRect.height / 2;
                const sectionDistanceFromCenter = Math.abs(sectionCenter - windowCenter);
                const normalizedSectionDistance = sectionDistanceFromCenter / windowHeight;

                if (normalizedSectionDistance > 0.8) {
                    problemSolutionSection.classList.add('is-section-blurring');
                } else {
                    problemSolutionSection.classList.remove('is-section-blurring');
                }

                // Apply differential vertical parallax to each card
                // Cards move AWAY from each other as you scroll through
                compCards.forEach((card, index) => {
                    // MUCH LARGER movement - Problem card goes UP, Solution card goes DOWN
                    // This creates a "spreading apart" effect
                    const maxOffset = index === 0 ? -120 : 120; // 120px each direction
                    
                    // Center the movement around 0.5 progress so cards move from -half to +half
                    const centeredProgress = (clampedProgress - 0.5) * 2; // -1 to 1
                    
                    // Calculate target offset
                    const targetOffset = maxOffset * centeredProgress;
                    
                    // Smooth interpolation (lerp) for buttery animation even during momentum scroll
                    // Higher value = more responsive, lower = smoother
                    const lerpFactor = 0.12;
                    currentOffsets[index] += (targetOffset - currentOffsets[index]) * lerpFactor;
                    
                    // Apply transform
                    card.style.transform = `translateY(${currentOffsets[index]}px)`;
                });

                lastScrollY = scrollY;

                // Continue the animation loop
                requestAnimationFrame(updateCompCards);
            }

            // Start the continuous animation loop
            requestAnimationFrame(updateCompCards);
        })();

        // ========================================
        // FAQ ITEMS - Subtle Staggered Parallax
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const faqSection = document.querySelector('.faq');
            const faqItems = document.querySelectorAll('.faq-item');
            if (!faqItems.length || !faqSection) return;

            // MUCH subtler alternating up/down pattern - reduced to prevent overlap
            const faqConfigs = [
                { maxOffset: -15 },   // up
                { maxOffset: 12 },    // down
                { maxOffset: -10 },   // up smaller
                { maxOffset: 18 },    // down
                { maxOffset: -14 },   // up
                { maxOffset: 10 },    // down smaller
                { maxOffset: -12 }    // up
            ];
            
            let faqOffsets = new Array(faqItems.length).fill(0);

            function updateFaqItems() {
                const windowHeight = window.innerHeight;
                const scrollY = window.scrollY;
                const sectionRect = faqSection.getBoundingClientRect();
                
                const sectionTop = sectionRect.top + scrollY;
                const sectionHeight = sectionRect.height;
                
                const effectStart = sectionTop - (windowHeight * 1.2);
                const effectEnd = sectionTop + sectionHeight + (windowHeight * 0.3);
                const effectRange = effectEnd - effectStart;
                
                const scrollProgress = (scrollY - effectStart) / effectRange;
                const clampedProgress = Math.min(Math.max(scrollProgress, 0), 1);

                faqItems.forEach((item, index) => {
                    const config = faqConfigs[index % faqConfigs.length];
                    const centeredProgress = (clampedProgress - 0.5) * 2;
                    const targetOffset = config.maxOffset * centeredProgress;
                    
                    const lerpFactor = 0.08; // Very smooth
                    faqOffsets[index] += (targetOffset - faqOffsets[index]) * lerpFactor;
                    
                    item.style.transform = `translateY(${faqOffsets[index]}px)`;
                });

                requestAnimationFrame(updateFaqItems);
            }

            requestAnimationFrame(updateFaqItems);
        })();

        // ========================================
        // HOW IT WORKS STEPS - Subtle Parallax
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const howSection = document.querySelector('.how-it-works');
            const stepItems = document.querySelectorAll('.step-item');
            if (!stepItems.length || !howSection) return;

            // Different rates for each step
            const stepConfigs = [
                { maxOffset: -60 },   // Step 1
                { maxOffset: 50 },    // Step 2 (opposite)
                { maxOffset: -45 }    // Step 3
            ];
            
            let stepOffsets = [0, 0, 0];

            function updateStepItems() {
                const windowHeight = window.innerHeight;
                const scrollY = window.scrollY;
                const sectionRect = howSection.getBoundingClientRect();
                
                const sectionTop = sectionRect.top + scrollY;
                const sectionHeight = sectionRect.height;
                
                const effectStart = sectionTop - (windowHeight * 1.3);
                const effectEnd = sectionTop + sectionHeight + (windowHeight * 0.4);
                const effectRange = effectEnd - effectStart;
                
                const scrollProgress = (scrollY - effectStart) / effectRange;
                const clampedProgress = Math.min(Math.max(scrollProgress, 0), 1);

                stepItems.forEach((item, index) => {
                    const config = stepConfigs[index] || stepConfigs[0];
                    const centeredProgress = (clampedProgress - 0.5) * 2;
                    const targetOffset = config.maxOffset * centeredProgress;
                    
                    const lerpFactor = 0.09;
                    stepOffsets[index] += (targetOffset - stepOffsets[index]) * lerpFactor;
                    
                    item.style.transform = `translateY(${stepOffsets[index]}px)`;
                });

                requestAnimationFrame(updateStepItems);
            }

            requestAnimationFrame(updateStepItems);
        })();

        // ========================================
        // BENEFITS CARDS - Varied Parallax (Different Random Rates)
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const benefitsSection = document.querySelector('.benefits');
            const benefitCards = document.querySelectorAll('.benefit-card');
            if (!benefitCards.length || !benefitsSection) return;

            // Each card gets a different movement direction and amount
            // Some go up, some go down, at different rates
            const cardConfigs = [
                { maxOffset: -140, direction: -1 },  // Card 1: moves up a lot
                { maxOffset: 100, direction: 1 },    // Card 2: moves down
                { maxOffset: -80, direction: -1 },   // Card 3: moves up less
                { maxOffset: 130, direction: 1 }     // Card 4: moves down a lot
            ];
            
            // Track current animated positions for smooth interpolation
            let benefitOffsets = [0, 0, 0, 0];

            function updateBenefitCards() {
                const windowHeight = window.innerHeight;
                const scrollY = window.scrollY;
                const sectionRect = benefitsSection.getBoundingClientRect();
                
                // Get the section's position relative to document
                const sectionTop = sectionRect.top + scrollY;
                const sectionHeight = sectionRect.height;
                
                // Calculate total scroll distance for the effect
                // Start early, continue late
                const effectStart = sectionTop - (windowHeight * 1.5);
                const effectEnd = sectionTop + sectionHeight + (windowHeight * 0.5);
                const effectRange = effectEnd - effectStart;
                
                // Calculate progress (0 = just starting, 1 = finished)
                const scrollProgress = (scrollY - effectStart) / effectRange;
                const clampedProgress = Math.min(Math.max(scrollProgress, 0), 1);

                // Apply parallax to each benefit card
                benefitCards.forEach((card, index) => {
                    const config = cardConfigs[index] || cardConfigs[0];
                    
                    // Center the movement around 0.5 progress
                    const centeredProgress = (clampedProgress - 0.5) * 2; // -1 to 1
                    
                    // Calculate target offset
                    const targetOffset = config.maxOffset * centeredProgress;
                    
                    // Smooth lerp interpolation
                    const lerpFactor = 0.1; // Slightly slower for smoother feel
                    benefitOffsets[index] += (targetOffset - benefitOffsets[index]) * lerpFactor;
                    
                    // Apply transform (keep any existing transforms from hover)
                    card.style.transform = `translateY(${benefitOffsets[index]}px)`;
                });

                requestAnimationFrame(updateBenefitCards);
            }

            // Start the continuous animation loop
            requestAnimationFrame(updateBenefitCards);
        })();

        // ========================================
        // REVIEW CARD 3D TILT EFFECT
        // ========================================
        (function() {
            if (prefersReducedMotion) return;

            const reviewCards = document.querySelectorAll('.review-card');
            if (!reviewCards.length) return;

            reviewCards.forEach(card => {
                // Track mouse position relative to card center
                card.addEventListener('mousemove', (e) => {
                    const rect = card.getBoundingClientRect();
                    const cardCenterX = rect.left + rect.width / 2;
                    const cardCenterY = rect.top + rect.height / 2;
                    
                    // Calculate distance from center (normalized to -1 to 1)
                    const mouseX = (e.clientX - cardCenterX) / (rect.width / 2);
                    const mouseY = (e.clientY - cardCenterY) / (rect.height / 2);
                    
                    // Apply subtle rotation (max 4 degrees) and slight lift
                    const rotateY = mouseX * 4; // Tilt left/right
                    const rotateX = -mouseY * 4; // Tilt up/down (inverted for natural feel)
                    const translateY = -4; // Slight lift on hover
                    
                    card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(${translateY}px)`;
                });

                // Reset on mouse leave
                card.addEventListener('mouseleave', () => {
                    card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) translateY(0)';
                });
            });
        })();

        // ========================================
        // FINAL ENHANCEMENTS (Typography, Ripple, Warmth)
        // ========================================
        (function() {
            // Guard prefersReducedMotion and viewport info
            const reduceMotion = typeof prefersReducedMotion !== 'undefined' && prefersReducedMotion;
            const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 767px)').matches;

            // 1. Button Ripple Effect (desktop only, no reduced motion)
            if (!reduceMotion && !isSmallScreen) {
                const buttons = document.querySelectorAll('.btn');
                buttons.forEach(btn => {
                    btn.addEventListener('click', function (e) {
                        const rect = this.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        const ripple = document.createElement('span');
                        ripple.className = 'ripple';
                        ripple.style.left = x + 'px';
                        ripple.style.top = y + 'px';
                        this.appendChild(ripple);
                        setTimeout(() => ripple.remove(), 600);
                    });
                });
            }

            // 2. Calm scroll hint (clickable link to next section)
            const hero = document.querySelector('.hero');
            const problemSection = document.querySelector('.problem-solution');
            if (hero && problemSection) {
                const scrollHint = document.createElement('a');
                scrollHint.className = 'scroll-hint';
                scrollHint.href = '#problem-solution';
                scrollHint.setAttribute('aria-label', 'Scroll down to learn more');
                scrollHint.innerHTML = '<span>Scroll to explore</span><div class="arrow-down" aria-hidden="true"></div>';
                hero.appendChild(scrollHint);
                
                // Add id to problem-solution section for scroll target
                problemSection.id = 'problem-solution';

                // fade scroll hint out as user scrolls past hero
                window.addEventListener('scroll', () => {
                    const rect = hero.getBoundingClientRect();
                    const progress = Math.min(Math.max(-rect.top / rect.height, 0), 1);
                    scrollHint.style.opacity = String(0.6 * (1 - progress));
                });
            }

            // 3. Hide particle canvas on small screens (keeps desktop effect)
            if (isSmallScreen) {
                const canvas = document.getElementById('particleCanvas');
                if (canvas) canvas.style.display = 'none';
            }

            // 4. Sticky CTA bar visibility based on scroll (mobile and desktop)
            const mobileCta = document.getElementById('mobileCtaBar');
            const desktopCta = document.getElementById('desktopCtaBar');
            const heroSection = document.querySelector('.hero');
            
            // Mobile CTA bar
            if (isSmallScreen && mobileCta && heroSection) {
                const toggleMobileCta = () => {
                    const rect = heroSection.getBoundingClientRect();
                    const pastHero = rect.bottom < (window.innerHeight * 0.5);
                    
                    if (pastHero) {
                        mobileCta.setAttribute('aria-hidden', 'false');
                        mobileCta.classList.add('is-visible');
                    } else {
                        mobileCta.setAttribute('aria-hidden', 'true');
                        mobileCta.classList.remove('is-visible');
                    }
                };
                
                // Initial check
                toggleMobileCta();
                
                // Throttled scroll listener
                let ticking = false;
                window.addEventListener('scroll', () => {
                    if (!ticking) {
                        window.requestAnimationFrame(() => {
                            toggleMobileCta();
                            ticking = false;
                        });
                        ticking = true;
                    }
                });
            }
            
            // Desktop CTA bar (for larger screens)
            if (!isSmallScreen && desktopCta && heroSection) {
                const toggleDesktopCta = () => {
                    const rect = heroSection.getBoundingClientRect();
                    const pastHero = rect.bottom < (window.innerHeight * 0.4);
                    
                    if (pastHero) {
                        desktopCta.setAttribute('aria-hidden', 'false');
                        desktopCta.classList.add('is-visible');
                    } else {
                        desktopCta.setAttribute('aria-hidden', 'true');
                        desktopCta.classList.remove('is-visible');
                    }
                };
                
                // Initial check
                toggleDesktopCta();
                
                // Throttled scroll listener
                let desktopTicking = false;
                window.addEventListener('scroll', () => {
                    if (!desktopTicking) {
                        window.requestAnimationFrame(() => {
                            toggleDesktopCta();
                            desktopTicking = false;
                        });
                        desktopTicking = true;
                    }
                });
            }
        })();

        // ========================================
        // IMAGE HOVER: 3D TILT + WATER SPLASH EFFECT
        // Applies to ALL images on the page
        // - 3D tilt: Image pivots around center based on cursor position
        // - Water splash: Droplets spawn where cursor hits with larger radius
        // ========================================
        (function() {
            if (prefersReducedMotion) return;
            
            // Check for touch devices / small screens
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isSmallScreen = window.matchMedia && window.matchMedia('(max-width: 768px)').matches;
            if (isTouchDevice || isSmallScreen) return;
            
            // Configuration
            const CONFIG = {
                // 3D Tilt settings - REDUCED for subtlety
                maxTiltDegrees: 4,            // Maximum rotation in degrees (was 12, now much subtler)
                tiltSmoothing: 0.08,          // Lerp factor (lower = smoother/slower)
                perspective: 1200,            // CSS perspective value (higher = less dramatic)
                
                // Splash settings - slightly more playful / slushy but still subtle
                splashRadius: 26,             // Radius around cursor for splash spawning (a touch wider)
                splashRate: 110,              // ms between splash spawns (slightly more frequent)
                dropletCount: 4,              // Droplets per spawn (a few more bubbles)
                dropletMinSize: 3,            // Minimum droplet size in px (slightly larger)
                dropletMaxSize: 7,            // Maximum droplet size in px (slightly larger)
                dropletLifespan: 750,         // How long droplets live in ms (linger a bit longer)
                dropletVelocity: 1.7,         // Base velocity for droplets (slightly livelier)
                dropletOpacity: 0.6,          // Starting opacity for droplets (a bit more visible)
                rippleEnabled: true,          // Show expanding ripple rings
                rippleInterval: 320           // ms between ripples (fractionally more often)
            };
            
            // Select ALL images on the page
            const allImages = document.querySelectorAll('img');
            
            // Track state for each image
            const imageStates = new Map();
            
            allImages.forEach(img => {
                // Skip very tiny images (icons, etc.) and images that might be problematic
                // Using naturalWidth/Height as backup since width/height might be 0 before load
                const imgWidth = img.width || img.naturalWidth || 100;
                const imgHeight = img.height || img.naturalHeight || 100;
                if (imgWidth < 30 || imgHeight < 30) return;
                if (img.closest('.satellite-droplet, .mercury-orb, .particle-canvas')) return;
                
                // Create state object for this image
                const state = {
                    currentTiltX: 0,
                    currentTiltY: 0,
                    targetTiltX: 0,
                    targetTiltY: 0,
                    isHovering: false,
                    lastSplashTime: 0,
                    lastRippleTime: 0,
                    animationFrame: null,
                    splashContainer: null
                };
                imageStates.set(img, state);
                
                // Get or create parent wrapper for proper positioning
                const parent = img.parentElement;
                if (parent) {
                    parent.style.position = parent.style.position || 'relative';
                    parent.style.overflow = 'hidden'; // CHANGED: hidden to prevent background showing through on tilt
                    
                    // Create splash container for this image
                    const splashContainer = document.createElement('div');
                    splashContainer.className = 'image-splash-container';
                    parent.appendChild(splashContainer);
                    state.splashContainer = splashContainer;
                }
                
                // Scale image slightly larger than container to hide edges during tilt
                img.style.width = '102%';
                img.style.height = '102%';
                img.style.objectFit = 'cover';
                img.style.margin = '-1%';
                
                // Set up transform origin at center
                img.style.transformOrigin = 'center center';
                img.style.transition = 'transform 0.1s ease-out';
                
                // ========== MOUSE ENTER ==========
                img.addEventListener('mouseenter', () => {
                    state.isHovering = true;
                    startTiltAnimation(img, state);
                });
                
                // ========== MOUSE MOVE ==========
                img.addEventListener('mousemove', (e) => {
                    if (!state.isHovering) return;
                    
                    const rect = img.getBoundingClientRect();
                    const imgCenterX = rect.left + rect.width / 2;
                    const imgCenterY = rect.top + rect.height / 2;
                    
                    // Calculate cursor position relative to image center (-1 to 1)
                    const relativeX = (e.clientX - imgCenterX) / (rect.width / 2);
                    const relativeY = (e.clientY - imgCenterY) / (rect.height / 2);
                    
                    // Clamp to -1 to 1 range
                    const clampedX = Math.max(-1, Math.min(1, relativeX));
                    const clampedY = Math.max(-1, Math.min(1, relativeY));
                    
                    // Set target tilt (note: rotateX tilts forward/back, rotateY tilts left/right)
                    // When cursor is at top (relativeY = -1), tilt forward (rotateX positive)
                    // When cursor is at left (relativeX = -1), tilt right edge toward viewer (rotateY negative)
                    state.targetTiltX = -clampedY * CONFIG.maxTiltDegrees;
                    state.targetTiltY = clampedX * CONFIG.maxTiltDegrees;
                    
                    // Spawn splash droplets
                    const now = Date.now();
                    if (now - state.lastSplashTime > CONFIG.splashRate) {
                        spawnSplashDroplets(e.clientX, e.clientY, rect, state);
                        state.lastSplashTime = now;
                    }
                    
                    // Spawn ripple occasionally
                    if (CONFIG.rippleEnabled && now - state.lastRippleTime > CONFIG.rippleInterval) {
                        spawnRipple(e.clientX, e.clientY, rect, state);
                        state.lastRippleTime = now;
                    }
                });
                
                // ========== MOUSE LEAVE ==========
                img.addEventListener('mouseleave', () => {
                    state.isHovering = false;
                    state.targetTiltX = 0;
                    state.targetTiltY = 0;
                    // Animation will continue to reset smoothly
                });
            });
            
            // ========== TILT ANIMATION LOOP ==========
            function startTiltAnimation(img, state) {
                if (state.animationFrame) return; // Already running
                
                function animate() {
                    // Lerp current values toward target
                    state.currentTiltX += (state.targetTiltX - state.currentTiltX) * CONFIG.tiltSmoothing;
                    state.currentTiltY += (state.targetTiltY - state.currentTiltY) * CONFIG.tiltSmoothing;
                    
                    // Apply transform
                    img.style.transform = `perspective(${CONFIG.perspective}px) rotateX(${state.currentTiltX}deg) rotateY(${state.targetTiltY}deg)`;
                    
                    // Continue animation if hovering OR still returning to rest
                    const isAtRest = Math.abs(state.currentTiltX) < 0.1 && Math.abs(state.currentTiltY) < 0.1;
                    
                    if (state.isHovering || !isAtRest) {
                        state.animationFrame = requestAnimationFrame(animate);
                    } else {
                        // Reset to exactly 0 and stop
                        img.style.transform = 'perspective(1000px) rotateX(0deg) rotateY(0deg)';
                        state.animationFrame = null;
                    }
                }
                
                state.animationFrame = requestAnimationFrame(animate);
            }
            
            // ========== SPAWN SPLASH DROPLETS ==========
            function spawnSplashDroplets(mouseX, mouseY, imgRect, state) {
                if (!state.splashContainer) return;
                
                // Calculate position relative to image
                const localX = mouseX - imgRect.left;
                const localY = mouseY - imgRect.top;
                
                for (let i = 0; i < CONFIG.dropletCount; i++) {
                    const droplet = document.createElement('div');
                    droplet.className = 'image-hover-droplet';
                    
                    // Random offset within splash radius
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * CONFIG.splashRadius;
                    const offsetX = Math.cos(angle) * distance;
                    const offsetY = Math.sin(angle) * distance;
                    
                    // Random size
                    const size = CONFIG.dropletMinSize + Math.random() * (CONFIG.dropletMaxSize - CONFIG.dropletMinSize);
                    
                    // Set initial position
                    const startX = localX + offsetX;
                    const startY = localY + offsetY;
                    
                    droplet.style.width = size + 'px';
                    droplet.style.height = size + 'px';
                    droplet.style.left = startX + 'px';
                    droplet.style.top = startY + 'px';
                    droplet.style.opacity = String(CONFIG.dropletOpacity);
                    
                    // Vary the droplet color slightly
                    const hueShift = (Math.random() - 0.5) * 20;
                    droplet.style.filter = `hue-rotate(${hueShift}deg)`;
                    
                    state.splashContainer.appendChild(droplet);
                    
                    // Animate the droplet
                    animateDroplet(droplet, startX, startY, angle);
                }
            }
            
            // ========== ANIMATE INDIVIDUAL DROPLET ==========
            function animateDroplet(droplet, startX, startY, angle) {
                let x = startX;
                let y = startY;
                
                // Random velocity direction (outward from spawn point)
                const speed = CONFIG.dropletVelocity * (0.6 + Math.random() * 0.7); // slightly wider speed range for a slushier feel
                let vx = Math.cos(angle) * speed;
                let vy = Math.sin(angle) * speed;
                
                // Physics - tuned for a softer, more fluid arc
                const gravity = 0.12;
                const friction = 0.94;
                
                let life = 0;
                const maxLife = CONFIG.dropletLifespan / 16; // Convert to frames (~60fps)
                let scale = 1;
                let rotation = Math.random() * 360;
                const rotationSpeed = (Math.random() - 0.5) * 8;
                
                function animate() {
                    life++;
                    
                    // Apply physics
                    vx *= friction;
                    vy *= friction;
                    vy += gravity;
                    x += vx;
                    y += vy;
                    rotation += rotationSpeed;
                    
                    // Calculate fade and scale
                    const progress = life / maxLife;
                    const opacity = Math.max(0, CONFIG.dropletOpacity * (1 - Math.pow(progress, 0.5))); // fades a touch more gradually
                    scale = 1 - (progress * 0.25);
                    
                    // Apply transforms
                    droplet.style.left = x + 'px';
                    droplet.style.top = y + 'px';
                    droplet.style.opacity = opacity;
                    droplet.style.transform = `scale(${scale}) rotate(${rotation}deg)`;
                    
                    if (life < maxLife && opacity > 0.01) {
                        requestAnimationFrame(animate);
                    } else {
                        droplet.remove();
                    }
                }
                
                // Small random delay for natural feel
                setTimeout(() => requestAnimationFrame(animate), Math.random() * 30);
            }
            
            // ========== SPAWN RIPPLE RING ==========
            function spawnRipple(mouseX, mouseY, imgRect, state) {
                if (!state.splashContainer) return;
                
                const ripple = document.createElement('div');
                ripple.className = 'image-hover-ripple';
                
                // Position at cursor
                const localX = mouseX - imgRect.left;
                const localY = mouseY - imgRect.top;
                
                ripple.style.left = localX + 'px';
                ripple.style.top = localY + 'px';
                ripple.style.width = '6px';
                ripple.style.height = '6px';
                ripple.style.opacity = '0.35';
                
                state.splashContainer.appendChild(ripple);
                
                // Animate ripple expansion
                let size = 10;
                let opacity = 0.6;
                let life = 0;
                const maxLife = 35;
                
                function animateRipple() {
                    life++;
                    size += 4;
                    opacity = 0.35 * (1 - life / maxLife);
                    
                    ripple.style.width = size + 'px';
                    ripple.style.height = size + 'px';
                    ripple.style.opacity = opacity;
                    
                    if (life < maxLife) {
                        requestAnimationFrame(animateRipple);
                    } else {
                        ripple.remove();
                    }
                }
                
                requestAnimationFrame(animateRipple);
            }
            
        })();
    </script>

    <style>
        /* ENHANCED TYPOGRAPHY & ACCESSIBILITY */
        p {
            line-height: 1.7;
            color: #374151; /* Softer than pure black */
        }
        
        /* WARMER FOOTER */
        footer {
            background: #E5E7EB !important; /* Warmer grey */
            border-top: 1px solid #D1D5DB;
        }

        /* RIPPLE EFFECT */
        .btn {
            position: relative;
            overflow: hidden;
        }
        .ripple {
            position: absolute;
            background: rgba(255, 255, 255, 0.25);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: rippleEffect 0.6s ease-out forwards; /* single, soft pulse */
        }
        @keyframes rippleEffect {
            0%   { width: 0; height: 0; opacity: 0.4; }
            100% { width: 260px; height: 260px; opacity: 0; }
        }

        /* Shopify Buy Button variant UI
           Ensure only our default variant is visually selectable by hiding
           any internal variant dropdowns or option selectors. The underlying
           product can still manage variants in Shopify; customers just see
           a single Akolo White choice on this page. */
        .shopify-buy__option-select,
        .shopify-buy__product__variant-select,
        .shopify-buy__options {
            display: none !important;
        }
        
        /* SCROLL HINT - Subtle animated chevron */
        .scroll-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            opacity: 0;
            animation: fadeInHint 0.6s ease-out 1.2s forwards, floatHint 2.5s ease-in-out 1.8s infinite;
            pointer-events: auto;
            z-index: 10;
            cursor: pointer;
            text-decoration: none;
            color: inherit;
        }
        .scroll-hint:hover {
            opacity: 0.9 !important;
        }
        .scroll-hint:focus {
            outline: 2px solid var(--color-accent);
            outline-offset: 4px;
            border-radius: 8px;
        }
        .scroll-hint span {
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--color-text-muted);
        }
        .arrow-down {
            width: 10px;
            height: 10px;
            border-right: 2px solid var(--color-accent);
            border-bottom: 2px solid var(--color-accent);
            transform: rotate(45deg);
            transition: transform 0.2s ease;
        }
        .scroll-hint:hover .arrow-down {
            transform: rotate(45deg) translate(2px, 2px);
        }
        @keyframes fadeInHint {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 0.6; transform: translateX(-50%) translateY(0); }
        }
        @keyframes floatHint {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(8px); }
        }
        @media (max-width: 768px) {
            .scroll-hint {
                display: none;
            }
        }
    </style>

    <!-- ========================================
         ANALYTICS TRACKING SCRIPT
         Lightweight custom tracking for page views, clicks, orb movement, and session data
         ======================================== -->
    <script>
    (function() {
        'use strict';
        
        // Defensive wrapper - do not break the page if tracking fails
        try {
            // ========================================
            // SESSION ID MANAGEMENT
            // ========================================
            function getOrCreateSessionId() {
                var key = 'smartSplashSessionId';
                var sessionId = null;
                try {
                    sessionId = localStorage.getItem(key);
                } catch (e) {
                    // localStorage unavailable (private mode, etc.)
                }
                if (!sessionId) {
                    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                        sessionId = crypto.randomUUID();
                    } else {
                        // Fallback for older browsers
                        sessionId = 'ss_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    }
                    try {
                        localStorage.setItem(key, sessionId);
                    } catch (e) {
                        // Ignore storage errors
                    }
                }
                return sessionId;
            }

            // ========================================
            // GLOBAL TRACKING CONFIG
            // ========================================
            window.trackerConfig = {
                sessionId: getOrCreateSessionId(),
                pageUrl: window.location.href,
                referrer: document.referrer || null,
                userAgent: navigator.userAgent,
                language: navigator.language || navigator.userLanguage || 'unknown',
                timezone: (function() {
                    try {
                        return Intl.DateTimeFormat().resolvedOptions().timeZone;
                    } catch (e) {
                        return 'unknown';
                    }
                })()
            };

            // ========================================
            // TRACKING COUNTERS
            // ========================================
            var totalClicksRecorded = 0;
            var totalOrbSamplesRecorded = 0;
            var pageStartTime = performance.now();

            // ========================================
            // SEND TRACKING EVENT HELPER
            // ========================================
            function sendTrackingEvent(eventType, data) {
                try {
                    var payload = {
                        eventType: eventType,
                        timestamp: new Date().toISOString(),
                        sessionId: window.trackerConfig.sessionId,
                        pageUrl: window.trackerConfig.pageUrl,
                        referrer: window.trackerConfig.referrer,
                        userAgent: window.trackerConfig.userAgent,
                        language: window.trackerConfig.language,
                        timezone: window.trackerConfig.timezone,
                        viewport: {
                            width: window.innerWidth,
                            height: window.innerHeight
                        },
                        data: data
                    };

                    var jsonPayload = JSON.stringify(payload);
                    var url = '/.netlify/functions/track';

                    // Prefer sendBeacon for reliability (especially on page unload)
                    if (navigator.sendBeacon) {
                        var blob = new Blob([jsonPayload], { type: 'application/json' });
                        var sent = navigator.sendBeacon(url, blob);
                        if (!sent) {
                            // Fallback to fetch if sendBeacon fails
                            fetch(url, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: jsonPayload,
                                keepalive: true
                            }).catch(function() {});
                        }
                    } else {
                        // Fallback for browsers without sendBeacon
                        fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: jsonPayload,
                            keepalive: true
                        }).catch(function() {});
                    }
                } catch (e) {
                    // Silently fail - do not break the page
                }
            }

            // ========================================
            // TRACK PAGE VIEW
            // ========================================
            function trackPageView() {
                sendTrackingEvent('page_view', {
                    title: document.title,
                    path: window.location.pathname,
                    search: window.location.search,
                    hash: window.location.hash
                });
            }

            // Fire page view on DOMContentLoaded
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', trackPageView);
            } else {
                trackPageView();
            }

            // ========================================
            // TRACK BUTTON CLICKS (Event Delegation)
            // ========================================
            document.body.addEventListener('click', function(e) {
                try {
                    // Find the nearest element with data-analytics-id
                    var target = e.target;
                    var element = null;
                    
                    // Walk up the DOM tree
                    while (target && target !== document.body) {
                        if (target.dataset && target.dataset.analyticsId) {
                            element = target;
                            break;
                        }
                        // Also catch buttons and anchor tags that might be CTAs
                        if ((target.tagName === 'BUTTON' || target.tagName === 'A') && 
                            target.classList && 
                            (target.classList.contains('btn') || target.classList.contains('btn-cta') || target.classList.contains('btn-primary'))) {
                            element = target;
                            break;
                        }
                        target = target.parentElement;
                    }

                    if (element) {
                        totalClicksRecorded++;
                        sendTrackingEvent('click', {
                            analyticsId: element.dataset.analyticsId || null,
                            tagName: element.tagName,
                            text: (element.innerText || '').slice(0, 120).trim(),
                            id: element.id || null,
                            className: element.className || null,
                            href: element.href || null
                        });
                    }
                } catch (e) {
                    // Silently fail
                }
            }, true);

            // ========================================
            // TRACK FAQ INTERACTIONS
            // ========================================
            document.body.addEventListener('click', function(e) {
                try {
                    var target = e.target;
                    while (target && target !== document.body) {
                        if (target.classList && target.classList.contains('faq-question')) {
                            var questionText = target.querySelector('.faq-question-text');
                            sendTrackingEvent('faq_toggle', {
                                question: questionText ? questionText.textContent.trim().slice(0, 200) : null,
                                expanded: target.getAttribute('aria-expanded') === 'false' // Will be toggled
                            });
                            break;
                        }
                        target = target.parentElement;
                    }
                } catch (e) {
                    // Silently fail
                }
            }, true);

            // ========================================
            // ORB / CURSOR MOVEMENT TRACKING
            // Hooks into the existing mercury orb mousemove handling
            // ========================================
            var orbPathBuffer = [];
            var orbSampleInterval = null;
            var ORB_SAMPLE_INTERVAL_MS = 4000; // Send samples every 4 seconds
            var MAX_POINTS_PER_SAMPLE = 100;

            // Start the orb sampling interval
            orbSampleInterval = setInterval(function() {
                try {
                    if (orbPathBuffer.length > 0) {
                        totalOrbSamplesRecorded++;
                        sendTrackingEvent('orb_path_sample', {
                            points: orbPathBuffer.slice(0, MAX_POINTS_PER_SAMPLE),
                            pointCount: orbPathBuffer.length,
                            sampleNumber: totalOrbSamplesRecorded
                        });
                        orbPathBuffer = [];
                    }
                } catch (e) {
                    // Silently fail
                }
            }, ORB_SAMPLE_INTERVAL_MS);

            // Throttle for mouse position recording (every 50ms = 20 samples/sec max)
            var lastOrbRecordTime = 0;
            var ORB_RECORD_THROTTLE_MS = 50;

            // Add listener for orb tracking - works alongside existing orb animation
            document.addEventListener('mousemove', function(e) {
                try {
                    var now = performance.now();
                    if (now - lastOrbRecordTime >= ORB_RECORD_THROTTLE_MS) {
                        lastOrbRecordTime = now;
                        // Cap buffer size to prevent memory issues
                        if (orbPathBuffer.length < 500) {
                            orbPathBuffer.push({
                                x: e.clientX,
                                y: e.clientY,
                                t: Math.round(now)
                            });
                        }
                    }
                } catch (e) {
                    // Silently fail
                }
            }, { passive: true });

            // ========================================
            // TRACK SCROLL DEPTH
            // ========================================
            var maxScrollDepth = 0;
            var scrollDepthMilestones = [25, 50, 75, 90, 100];
            var scrollMilestonesSent = {};

            function calculateScrollDepth() {
                var scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                var docHeight = document.documentElement.scrollHeight - window.innerHeight;
                if (docHeight <= 0) return 100;
                return Math.round((scrollTop / docHeight) * 100);
            }

            var scrollThrottleTimeout = null;
            window.addEventListener('scroll', function() {
                if (scrollThrottleTimeout) return;
                scrollThrottleTimeout = setTimeout(function() {
                    scrollThrottleTimeout = null;
                    try {
                        var depth = calculateScrollDepth();
                        if (depth > maxScrollDepth) {
                            maxScrollDepth = depth;
                            // Check if we hit a milestone
                            for (var i = 0; i < scrollDepthMilestones.length; i++) {
                                var milestone = scrollDepthMilestones[i];
                                if (depth >= milestone && !scrollMilestonesSent[milestone]) {
                                    scrollMilestonesSent[milestone] = true;
                                    sendTrackingEvent('scroll_depth', {
                                        milestone: milestone,
                                        actualDepth: depth
                                    });
                                }
                            }
                        }
                    } catch (e) {
                        // Silently fail
                    }
                }, 200);
            }, { passive: true });

            // ========================================
            // SESSION SUMMARY ON PAGE UNLOAD
            // ========================================
            function sendSessionSummary() {
                try {
                    // Send any remaining orb data
                    if (orbPathBuffer.length > 0) {
                        totalOrbSamplesRecorded++;
                        sendTrackingEvent('orb_path_sample', {
                            points: orbPathBuffer.slice(0, MAX_POINTS_PER_SAMPLE),
                            pointCount: orbPathBuffer.length,
                            sampleNumber: totalOrbSamplesRecorded,
                            isFinal: true
                        });
                        orbPathBuffer = [];
                    }

                    sendTrackingEvent('session_summary', {
                        durationMs: Math.round(performance.now() - pageStartTime),
                        totalClicks: totalClicksRecorded,
                        totalOrbSamples: totalOrbSamplesRecorded,
                        maxScrollDepth: maxScrollDepth,
                        scrollMilestones: Object.keys(scrollMilestonesSent).map(Number)
                    });
                } catch (e) {
                    // Silently fail
                }
            }

            // Use visibilitychange (more reliable) and beforeunload (fallback)
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'hidden') {
                    sendSessionSummary();
                }
            });

            window.addEventListener('beforeunload', function() {
                sendSessionSummary();
            });

            // Clean up interval on page unload
            window.addEventListener('pagehide', function() {
                if (orbSampleInterval) {
                    clearInterval(orbSampleInterval);
                }
            });

        } catch (e) {
            // Top-level catch - ensure nothing breaks the page
            console.warn('Tracking initialization failed:', e);
        }
    })();

    // ========================================
    // UNIFIED WATER SYSTEM
    // One continuous simulation: glass shelf → overflow → page ground
    // Features: Single waterDrops array, natural overflow, perspective,
    // cursor emission everywhere, merging, scroll slosh
    // ========================================
    (function initUnifiedWaterSystem() {
        const header = document.getElementById('header');
        const condCanvas = document.getElementById('condensationCanvas');
        const shadowCanvas = document.getElementById('shadowCanvas');
        const pageCanvas = document.getElementById('pageWaterCanvas');
        
        if (!header || !condCanvas || !shadowCanvas || !pageCanvas) return;
        
        const condCtx = condCanvas.getContext('2d');
        const shadowCtx = shadowCanvas.getContext('2d');
        const pageCtx = pageCanvas.getContext('2d');
        
        const mediaHoverNone = window.matchMedia && window.matchMedia('(hover: none)').matches;
        const reducedMotionSetting = typeof prefersReducedMotion !== 'undefined'
            ? prefersReducedMotion
            : (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
        const interactive = !(mediaHoverNone || reducedMotionSetting);
        
        // =============================================
        // CONFIGURATION
        // =============================================
        
        // --- Condensation ---
        const SPOT_COUNT = 450;
        const COND_MIN_SIZE = 2.5;
        const COND_MAX_SIZE = 28;
        
        // --- Wipe/brush ---
        const WIPE_RADIUS = 80;
        const WIPE_STRENGTH = 0.032;
        const WIPE_RESIDUE = 0.85;
        const WIPE_RECOVERY_RATE = 0.00012;
        const WIPE_RECOVERY_HOLD = 200;
        const WIPE_DWELL_BOOST = 1.45;
        const WIPE_PASS_BOOST = 1.0;
        
        // --- Shadow/crater ---
        const SHADOW_MAX_ALPHA = 0.10;
        const SHADOW_SPREAD = 1.25;
        const SHADOW_JITTER = 25;
        const MAX_SHADOWS = 35;
        const SHADOW_LIFETIME = 2800;
        
        // --- UNIFIED WATER ---
        const MAX_WATER_DROPS = 80;
        const WATER_MIN_RADIUS = 2;
        const WATER_MAX_RADIUS = 6;
        const WATER_LIFETIME = 12000;
        
        // --- Shelf (glass) physics ---
        const SHELF_SLOPE_X = 0;
        const SHELF_SLOPE_Y = 0.0003;
        const SHELF_FRICTION = 0.997;
        const SHELF_STICK_TIME = 500;
        const SHELF_FRONT_BUFFER = 8;
        const SHELF_OVERFLOW_BOOST = 0.02;
        
        // --- Ground (page) physics ---
        const GRAVITY = 0.0018;
        const GROUND_FRICTION = 0.994;
        const GROUND_SLOPE_X = 0.00015;
        const GROUND_SLOPE_Y = 0.0004;
        const GROUND_Y_RATIO = 0.88;
        
        // --- Cursor ---
        const CURSOR_EMIT_BASE = 0.035;
        const CURSOR_EMIT_HEADER = 0.052;
        const CURSOR_REPULSE_RADIUS = 100;
        const CURSOR_REPULSE_FORCE = 0.015;
        
        // --- Merging ---
        const MERGE_DISTANCE = 8;
        const MERGE_RADIUS_FACTOR = 0.7;
        const MAX_MERGE_CHECKS = 25;
        
        // --- Scroll ---
        const SCROLL_FORCE = 1.5;
        const SCROLL_SLOSH_THRESHOLD = 0.2;
        const SCROLL_SPILL_THRESHOLD = 0.35;
        
        // --- Perspective ---
        const PERSPECTIVE_TOP = 0.82;
        const PERSPECTIVE_MID = 1.0;
        const PERSPECTIVE_BOTTOM = 1.12;
        
        // --- Fluid band (shelf edge pool) ---
        const FLUID_SEGMENTS = 48;
        const FLUID_DAMPING = 0.975;
        const FLUID_STIFFNESS = 0.16;
        const FLUID_SPREAD = 0.28;
        const FLUID_BASE_HEIGHT = 6;
        const FLUID_SPILL_THRESHOLD = 12;
        const FLUID_SCROLL_MULT = 2.0;
        
        // --- Condensation shimmer ---
        const SHIMMER_SPEED = 0.0004;
        const SHIMMER_AMPLITUDE = 0.035;
        const EQUILIBRIUM_RADIUS = 110;
        const RIPPLE_SPEED = 0.00028;
        const RIPPLE_SCALE = 0.0014;
        
        // --- Regrowth ---
        const NEW_COND_CHANCE = 0.0032;
        const NEW_COND_RATE = 0.0035;
        const MAX_NEW_OPACITY = 0.48;
        const MIN_BASE_OPACITY = 0.18;
        const REGROW_DELAY = 1600;
        const REGROW_VARIANCE = 1400;
        const RESPREAD_MIN = 14;
        const RESPREAD_MAX = 38;
        const MAX_RECENT_WIPES = 50;
        
        // --- Hover tint ---
        const HOVER_FADE_RAMP = 3200;
        const HOVER_FADE_DECAY = 1800;
        
        // =============================================
        // STATE
        // =============================================
        
        // Condensation
        let condensationSpots = [];
        let dynamicShadows = [];
        let recentWipeZones = [];
        
        // UNIFIED WATER - single array for ALL water
        // Each drop: { x, y, vx, vy, radius, alpha, onShelf, lifetime, stickStart, gloss }
        let waterDrops = [];
        
        // Fluid band at shelf front edge
        let fluidHeights = [];
        let fluidVelocities = [];
        
        // Cursor
        let cursorX = -1000;
        let cursorY = -1000;
        let lastCursorX = -1000;
        let lastCursorY = -1000;
        let cursorVx = 0;
        let cursorVy = 0;
        let isHoveringHeader = false;
        
        // Timing
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let hoverTime = 0;
        let lightPhase = 0;
        
        // Dimensions
        let headerWidth = 0;
        let headerHeight = 0;
        let pageWidth = window.innerWidth;
        let pageHeight = window.innerHeight;
        let shelfTopY = 0;
        let shelfBottomY = 80;
        let groundY = 0;
        let dpr = 1;
        
        // Scroll
        let lastScrollY = window.pageYOffset || 0;
        let scrollSpeed = 0;
        
        // =============================================
        // UTILITIES
        // =============================================
        
        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        function noise(x, y, t) {
            const nx = x * RIPPLE_SCALE + t;
            const ny = y * RIPPLE_SCALE + t * 0.7;
            return Math.sin(nx) * Math.cos(ny) * 0.5 + 0.5;
        }
        
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }
        
        function dist(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function depthFactor(y) {
            const ratio = y / pageHeight;
            if (ratio < 0.25) {
                return PERSPECTIVE_TOP + (PERSPECTIVE_MID - PERSPECTIVE_TOP) * (ratio / 0.25);
            } else if (ratio < 0.65) {
                return PERSPECTIVE_MID;
            } else {
                return PERSPECTIVE_MID + (PERSPECTIVE_BOTTOM - PERSPECTIVE_MID) * ((ratio - 0.65) / 0.35);
            }
        }
        
        // =============================================
        // CONDENSATION HELPERS
        // =============================================
        
        function generateOctagonalShape(baseRadius, seed) {
            const points = [];
            const sides = 7 + Math.floor(seededRandom(seed) * 3);
            const irregularity = 0.35 + seededRandom(seed + 0.5) * 0.45;
            const angleOffset = seededRandom(seed + 0.3) * Math.PI * 0.25;
            
            for (let i = 0; i < sides; i++) {
                const baseAngle = (i / sides) * Math.PI * 2 - Math.PI / 2 + angleOffset;
                const angularJitter = (seededRandom(seed + i * 2.7) - 0.5) * 0.15;
                const angle = baseAngle + angularJitter;
                const radiusVariation = 1 + (seededRandom(seed + i) - 0.5) * irregularity;
                const r = baseRadius * radiusVariation;
                points.push({ x: Math.cos(angle) * r, y: Math.sin(angle) * r });
            }
            return points;
        }
        
        function drawPolygon(ctx, points, fillStyle) {
            if (points.length < 3) return;
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = fillStyle;
            ctx.fill();
        }
        
        function sizeFromRandom(randVal) {
            if (randVal < 0.5) {
                return COND_MIN_SIZE + (7 - COND_MIN_SIZE) * (randVal / 0.5);
            } else if (randVal < 0.85) {
                return 7 + (15 - 7) * ((randVal - 0.5) / 0.35);
            }
            return 15 + (COND_MAX_SIZE - 15) * ((randVal - 0.85) / 0.15);
        }

        function createRandomSpot(baseX, baseY, spreadRadius) {
            const angle = Math.random() * Math.PI * 2;
            const d = Math.random() * spreadRadius;
            const x = baseX + Math.cos(angle) * d;
            const y = baseY + Math.sin(angle) * d;
            const sizeRand = Math.random();
            const size = sizeFromRandom(sizeRand);
            const seed = Math.random() * 10000;
            const baseOpacity = MIN_BASE_OPACITY + Math.random() * (MAX_NEW_OPACITY - MIN_BASE_OPACITY);
            return {
                x: clamp(x, 0, headerWidth),
                y: clamp(y, 0, headerHeight),
                size: size,
                shapePoints: generateOctagonalShape(size / 2, seed),
                baseOpacity: baseOpacity,
                currentOpacity: 0,
                targetOpacity: baseOpacity,
                wipedAmount: 0,
                breathPhase: Math.random() * Math.PI * 2,
                seed: seed,
                isNew: true,
                fadeInProgress: 0,
                lastTouched: time,
                regrowDelay: REGROW_DELAY + Math.random() * REGROW_VARIANCE
            };
        }
        
        function createDynamicShadow(x, y, intensity) {
            const jitterAngle = Math.random() * Math.PI * 2;
            const jitterDist = Math.random() * SHADOW_JITTER;
            const shadowX = x + Math.cos(jitterAngle) * jitterDist;
            const shadowY = y + Math.sin(jitterAngle) * jitterDist;
            const driftAngle = Math.random() * Math.PI * 2;
            const driftDist = 6 + Math.random() * 12;
            return {
                x: shadowX,
                y: shadowY,
                targetX: shadowX + Math.cos(driftAngle) * driftDist,
                targetY: shadowY + Math.sin(driftAngle) * driftDist,
                size: 5 + Math.random() * 12,
                alpha: Math.min(SHADOW_MAX_ALPHA, intensity * SHADOW_MAX_ALPHA),
                maxAlpha: Math.min(SHADOW_MAX_ALPHA, intensity * SHADOW_MAX_ALPHA),
                createdAt: time,
                lifetime: SHADOW_LIFETIME + Math.random() * 800
            };
        }
        
        // =============================================
        // UNIFIED WATER DROPLET - Single type for all water
        // =============================================
        
        function createWaterDrop(x, y, vx, vy, onShelf) {
            const radius = WATER_MIN_RADIUS + Math.random() * (WATER_MAX_RADIUS - WATER_MIN_RADIUS);
            return {
                x: x,
                y: y,
                vx: vx || 0,
                vy: vy || 0,
                radius: radius,
                alpha: 0.88 + Math.random() * 0.1,
                onShelf: onShelf || false,
                lifetime: 0,
                stickStart: onShelf ? time : 0,
                gloss: 0.4 + Math.random() * 0.35
            };
        }
        
        // Reuse weakest droplet when at capacity
        function reuseOrCreateDrop(x, y, vx, vy, onShelf) {
            if (waterDrops.length < MAX_WATER_DROPS) {
                waterDrops.push(createWaterDrop(x, y, vx, vy, onShelf));
            } else {
                // Find weakest (lowest alpha or oldest)
                let weakestIdx = 0;
                let weakestScore = Infinity;
                for (let i = 0; i < waterDrops.length; i++) {
                    const score = waterDrops[i].alpha * 100 - waterDrops[i].lifetime * 0.01;
                    if (score < weakestScore) {
                        weakestScore = score;
                        weakestIdx = i;
                    }
                }
                // Replace it
                waterDrops[weakestIdx] = createWaterDrop(x, y, vx, vy, onShelf);
            }
        }
        
        // =============================================
        // INITIALIZATION
        // =============================================
        
        function initCondensationSpots() {
            condensationSpots = [];
            dynamicShadows = [];
            
            for (let i = 0; i < SPOT_COUNT; i++) {
                const seed = i * 127.1;
                const x = seededRandom(seed) * headerWidth;
                const y = seededRandom(seed + 1) * headerHeight;
                
                const sizeRand = seededRandom(seed + 2);
                const size = sizeFromRandom(sizeRand);
                
                const baseOpacity = MIN_BASE_OPACITY + seededRandom(seed + 4) * (MAX_NEW_OPACITY - MIN_BASE_OPACITY);
                const targetOpacity = baseOpacity * (0.9 + seededRandom(seed + 6) * 0.15);
                
                condensationSpots.push({
                    x: x,
                    y: y,
                    size: size,
                    shapePoints: generateOctagonalShape(size / 2, seed),
                    baseOpacity: baseOpacity,
                    currentOpacity: targetOpacity,
                    targetOpacity: targetOpacity,
                    wipedAmount: 0,
                    breathPhase: seededRandom(seed + 5) * Math.PI * 2,
                    seed: seed,
                    isNew: false,
                    fadeInProgress: 1,
                    lastTouched: time,
                    regrowDelay: REGROW_DELAY + seededRandom(seed + 7) * REGROW_VARIANCE
                });
            }
        }
        
        function initFluidBand() {
            fluidHeights = new Array(FLUID_SEGMENTS).fill(0);
            fluidVelocities = new Array(FLUID_SEGMENTS).fill(0);
            // Seed initial water pooled near front edge
            addFluidMass(headerWidth * 0.3, 8);
            addFluidMass(headerWidth * 0.6, 10);
            addFluidMass(headerWidth * 0.8, 6);
        }
        
        function initWaterDrops() {
            waterDrops = [];
            // Pre-seed a few drops on the shelf
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * headerWidth;
                const y = shelfBottomY - 10 - Math.random() * 40;
                reuseOrCreateDrop(x, y, 0, 0, true);
            }
        }
        
        function resizeAll() {
            dpr = window.devicePixelRatio || 1;
            pageWidth = window.innerWidth;
            pageHeight = window.innerHeight;
            groundY = pageHeight * GROUND_Y_RATIO;
            
            // Header canvases
            const rect = header.getBoundingClientRect();
            headerWidth = rect.width;
            headerHeight = rect.height;
            shelfTopY = rect.top + window.pageYOffset;
            shelfBottomY = rect.bottom + window.pageYOffset;
            
            condCanvas.width = headerWidth * dpr;
            condCanvas.height = headerHeight * dpr;
            condCanvas.style.width = headerWidth + 'px';
            condCanvas.style.height = headerHeight + 'px';
            
            shadowCanvas.width = headerWidth * dpr;
            shadowCanvas.height = headerHeight * dpr;
            shadowCanvas.style.width = headerWidth + 'px';
            shadowCanvas.style.height = headerHeight + 'px';
            
            condCtx.setTransform(1, 0, 0, 1, 0, 0);
            shadowCtx.setTransform(1, 0, 0, 1, 0, 0);
            condCtx.scale(dpr, dpr);
            shadowCtx.scale(dpr, dpr);
            
            // Page water canvas
            pageCanvas.width = pageWidth;
            pageCanvas.height = pageHeight;
            pageCanvas.style.width = pageWidth + 'px';
            pageCanvas.style.height = pageHeight + 'px';
            pageCtx.setTransform(1, 0, 0, 1, 0, 0);
            
            initCondensationSpots();
            initFluidBand();
            initWaterDrops();
        }
        
        // --- Rendering ---
        function drawCondensationSpot(ctx, spot, globalRipple) {
            const wipeInfluence = 1 - spot.wipedAmount * WIPE_RESIDUE;
            let alpha = spot.currentOpacity * wipeInfluence * spot.fadeInProgress;
            
            // Per-droplet shimmer (very subtle, like air currents)
            const shimmer = Math.sin(time * SHIMMER_SPEED + spot.breathPhase + spot.x * 0.01) * SHIMMER_AMPLITUDE;
            alpha += shimmer;
            
            // Apply global ripple
            const rippleMod = (globalRipple - 0.5) * 0.045;
            alpha += rippleMod;
            
            // Local breathing near cursor (subtle warmth effect)
            if (isHovering) {
                const dx = spot.x - cursorX;
                const dy = spot.y - cursorY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < EQUILIBRIUM_RADIUS) {
                    const breath = Math.sin(time * 0.003 + spot.breathPhase) * 0.04;
                    const influence = 1 - (dist / EQUILIBRIUM_RADIUS);
                    alpha += breath * influence * 0.7;
                }
            }
            
            // Clamp alpha to narrow range (no harsh bright-white spots)
            alpha = Math.max(0, Math.min(0.52, alpha));
            if (alpha <= 0.008) return;
            
            ctx.save();
            ctx.translate(spot.x, spot.y);
            
            // Time-varying specular glint direction
            const glintPhase = time * 0.0008;
            const glintOffsetX = -spot.size * (0.12 + Math.sin(glintPhase + spot.seed * 0.1) * 0.04);
            const glintOffsetY = -spot.size * (0.12 + Math.cos(glintPhase * 0.7 + spot.seed * 0.1) * 0.03);
            
            // Main droplet gradient - wet bead on glass appearance
            const gradient = ctx.createRadialGradient(
                glintOffsetX, glintOffsetY, 0,
                0, 0, spot.size / 2
            );
            
            // Soft gradient: white core -> aqua mid -> transparent edge
            gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.52})`);
            gradient.addColorStop(0.25, `rgba(240, 250, 255, ${alpha * 0.38})`);
            gradient.addColorStop(0.5, `rgba(215, 242, 252, ${alpha * 0.22})`);
            gradient.addColorStop(0.75, `rgba(195, 230, 248, ${alpha * 0.10})`);
            gradient.addColorStop(1, `rgba(180, 220, 242, ${alpha * 0.03})`);
            
            drawPolygon(ctx, spot.shapePoints, gradient);
            
            // Specular highlight (responds to time/light direction)
            if (spot.size > 4.5 && alpha > 0.18) {
                const highlightAlpha = alpha * (0.22 + Math.sin(glintPhase * 1.3 + spot.x * 0.005) * 0.06);
                const hGrad = ctx.createRadialGradient(
                    glintOffsetX * 1.2, glintOffsetY * 1.2, 0,
                    glintOffsetX * 0.5, glintOffsetY * 0.5, spot.size * 0.2
                );
                hGrad.addColorStop(0, `rgba(255, 255, 255, ${highlightAlpha})`);
                hGrad.addColorStop(0.6, `rgba(255, 255, 255, ${highlightAlpha * 0.3})`);
                hGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.beginPath();
                ctx.arc(glintOffsetX, glintOffsetY, spot.size * 0.16, 0, Math.PI * 2);
                ctx.fillStyle = hGrad;
                ctx.fill();
            }

            // Subtle wet sheen streak (glassy reflection)
            if (spot.size > 5 && alpha > 0.1) {
                ctx.save();
                ctx.rotate(-Math.PI / 6 + spot.seed * 0.05);
                const streakLen = spot.size * 0.6;
                const streakGrad = ctx.createLinearGradient(
                    -streakLen * 0.55, -streakLen * 0.55,
                    streakLen * 0.65, streakLen * 0.65
                );
                streakGrad.addColorStop(0, `rgba(255,255,255,${alpha * 0.04})`);
                streakGrad.addColorStop(0.4, `rgba(255,255,255,${alpha * 0.14})`);
                streakGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.strokeStyle = streakGrad;
                ctx.lineWidth = Math.max(0.5, spot.size * 0.055);
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(-streakLen * 0.45, -streakLen * 0.45);
                ctx.lineTo(streakLen * 0.5, streakLen * 0.5);
                ctx.stroke();
                ctx.restore();
            }
            
            ctx.restore();
        }
        
        function drawDynamicShadow(ctx, shadow) {
            if (shadow.alpha <= 0.004) return;
            
            ctx.save();
            ctx.translate(shadow.x, shadow.y);
            
            // Soft shadow/crater darkening (smudged wet glass look)
            const spreadSize = shadow.size * SHADOW_SPREAD;
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, spreadSize);
            // Muted blue-gray tone for wet glass shadow
            gradient.addColorStop(0, `rgba(85, 120, 145, ${shadow.alpha * 0.48})`);
            gradient.addColorStop(0.35, `rgba(75, 112, 138, ${shadow.alpha * 0.28})`);
            gradient.addColorStop(0.7, `rgba(68, 105, 130, ${shadow.alpha * 0.12})`);
            gradient.addColorStop(1, 'rgba(60, 95, 120, 0)');
            
            ctx.beginPath();
            ctx.arc(0, 0, spreadSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            ctx.restore();
        }

        function spawnDroplet(x, y, strength) {
            if (!interactiveMode) return;
            if (waterDroplets.length >= DRIP_MAX) return;
            
            const angle = Math.random() * Math.PI * 2;
            const dist = (Math.random() * 8 + 4) * strength;
            const jitterX = x + Math.cos(angle) * dist;
            const jitterY = y + Math.sin(angle) * dist;
            // Larger, more visible droplets
            const radius = 1.8 + Math.random() * 2.8 * strength;
            
            waterDroplets.push({
                x: jitterX,
                y: jitterY,
                vx: (Math.random() - 0.5) * 0.06,
                vy: -0.004 + Math.random() * 0.025, // Mostly upward (toward top edge)
                r: radius,
                alpha: 0.92,
                gloss: Math.random() * 0.35 + 0.45, // Stronger highlights
                flowFactor: 0.9 + Math.random() * 0.2,
                age: 0,
                sticking: true // Start in stick phase
            });
        }

        function spawnSplash(x, y, baseStrength) {
            const count = Math.max(3, Math.round(SPLASH_PARTICLES * baseStrength));
            for (let i = 0; i < count; i++) {
                const ang = Math.random() * Math.PI + Math.PI; // downward spread
                const speed = 0.08 + Math.random() * 0.08 * baseStrength;
                splashParticles.push({
                    x,
                    y,
                    vx: Math.cos(ang) * speed,
                    vy: Math.sin(ang) * speed,
                    alpha: 0.6 + Math.random() * 0.3,
                    r: 0.6 + Math.random() * 0.6
                });
            }
        }

        function drawDroplet(ctx, drop) {
            ctx.save();
            ctx.translate(drop.x, drop.y);
            
            // Time-varying light glint for wet shine effect
            const lightGlint = 0.65 + 0.3 * Math.sin(lightPhase + drop.x * 0.003);
            
            // Main droplet gradient - clearly visible cyan/aqua water
            const grad = ctx.createRadialGradient(
                -drop.r * 0.28, -drop.r * 0.28, 0,
                0, 0, drop.r * 1.5
            );
            grad.addColorStop(0, `rgba(255, 255, 255, ${drop.alpha * 0.38})`);
            grad.addColorStop(0.3, `rgba(185, 235, 255, ${drop.alpha * 0.65})`);
            grad.addColorStop(0.6, `rgba(120, 210, 250, ${drop.alpha * 0.42})`);
            grad.addColorStop(0.85, `rgba(90, 190, 240, ${drop.alpha * 0.18})`);
            grad.addColorStop(1, `rgba(75, 170, 225, 0)`);
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            // Slightly elongated ellipse (teardrop-ish)
            ctx.ellipse(0, 0, drop.r * 1.15, drop.r * 1.42, -0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // Strong specular highlight for visibility
            ctx.beginPath();
            ctx.arc(-drop.r * 0.18, -drop.r * 0.32, drop.r * 0.36, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255,255,255,${drop.alpha * drop.gloss * 0.52 * lightGlint})`;
            ctx.fill();
            
            // Secondary smaller highlight
            if (drop.r > 2) {
                ctx.beginPath();
                ctx.arc(drop.r * 0.15, drop.r * 0.2, drop.r * 0.18, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${drop.alpha * 0.15 * lightGlint})`;
                ctx.fill();
            }
            
            ctx.restore();
        }

        function drawSplash(ctx, p) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.fillStyle = `rgba(90, 200, 255, ${p.alpha * 0.6})`;
            ctx.beginPath();
            ctx.arc(0, 0, p.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function initFluid() {
            fluidHeights = new Array(FLUID_SEGMENTS).fill(0);
            fluidVelocities = new Array(FLUID_SEGMENTS).fill(0);
            // Seed initial water so band is visible on load
            addFluidMass(canvasWidth * 0.3, 8);
            addFluidMass(canvasWidth * 0.6, 10);
            addFluidMass(canvasWidth * 0.8, 6);
        }

        function addFluidMass(x, amount) {
            if (!fluidHeights.length) return;
            const idx = clamp(Math.round((x / Math.max(1, canvasWidth)) * (FLUID_SEGMENTS - 1)), 0, FLUID_SEGMENTS - 1);
            const spread = 2;
            for (let i = -spread; i <= spread; i++) {
                const k = idx + i;
                if (k >= 0 && k < FLUID_SEGMENTS) {
                    const falloff = 1 - Math.abs(i) / (spread + 1);
                    fluidHeights[k] += amount * 0.55 * falloff;
                }
            }
        }

        function updateFluid(dt) {
            if (!fluidHeights.length) return;
            
            // Wave propagation
            const accel = new Array(FLUID_SEGMENTS).fill(0);
            for (let i = 0; i < FLUID_SEGMENTS; i++) {
                const left = i > 0 ? fluidHeights[i - 1] : fluidHeights[i];
                const right = i < FLUID_SEGMENTS - 1 ? fluidHeights[i + 1] : fluidHeights[i];
                const center = fluidHeights[i];
                accel[i] = (left - 2 * center + right) * FLUID_STIFFNESS;
            }
            
            for (let i = 0; i < FLUID_SEGMENTS; i++) {
                fluidVelocities[i] += accel[i] * (dt / 16);
                fluidVelocities[i] *= FLUID_DAMPING;
            }
            
            // Lateral spreading
            for (let i = 0; i < FLUID_SEGMENTS; i++) {
                const diffLeft = i > 0 ? (fluidHeights[i] - fluidHeights[i - 1]) * FLUID_SPREAD : 0;
                const diffRight = i < FLUID_SEGMENTS - 1 ? (fluidHeights[i] - fluidHeights[i + 1]) * FLUID_SPREAD : 0;
                if (i > 0) fluidVelocities[i - 1] += diffLeft;
                if (i < FLUID_SEGMENTS - 1) fluidVelocities[i + 1] += diffRight;
            }
            
            // Apply scroll-based sloshing (much stronger for visible slosh)
            const scrollMag = Math.abs(scrollSpeed);
            const scrollImpulse = scrollSpeed * FLUID_SCROLL_INFLUENCE * 0.18;
            
            for (let i = 0; i < FLUID_SEGMENTS; i++) {
                // Scroll creates wave motion across the band
                const scrollPhase = (i / FLUID_SEGMENTS) * Math.PI;
                fluidVelocities[i] += scrollImpulse * Math.sin(scrollPhase + time * 0.002);
                
                fluidHeights[i] += fluidVelocities[i];
                // Gentle baseline decay
                fluidHeights[i] *= 0.9991;
            }

            // Spill droplets when over threshold - can spill to PAGE or back into header
            const step = canvasWidth / (FLUID_SEGMENTS - 1 || 1);
            for (let i = 0; i < FLUID_SEGMENTS; i++) {
                if (fluidHeights[i] > FLUID_SPILL_THRESHOLD) {
                    const spillAmt = (fluidHeights[i] - FLUID_SPILL_THRESHOLD) * FLUID_SPILL_RATE;
                    fluidHeights[i] -= spillAmt;
                    const x = i * step;
                    
                    // Decide: spill to page (downward) or back into header
                    const spillsToPage = Math.random() < FLUID_PAGE_SPILL_CHANCE || scrollMag > 0.25;
                    
                    if (spillsToPage && spillDroplets.length < 20) {
                        // This droplet will fall down onto the main page
                        // Dispatch to page water system via custom event
                        const spillEvent = new CustomEvent('headerWaterSpill', {
                            detail: {
                                x: x,
                                y: canvasHeight, // Bottom of header
                                vx: (Math.random() - 0.5) * 0.04 + scrollSpeed * 0.08,
                                vy: 0.06 + Math.random() * 0.04,
                                r: 2.2 + Math.random() * 2.5
                            }
                        });
                        window.dispatchEvent(spillEvent);
                    }
                    
                    // Also spawn some that stay on header (fall back into glass)
                    if (spillDroplets.length < 15 && Math.random() < 0.5) {
                        spillDroplets.push({
                            x,
                            y: POOL_OFFSET_TOP + FLUID_BASE_HEIGHT + 2,
                            vx: (Math.random() - 0.5) * 0.07,
                            vy: 0.055 + Math.random() * 0.045,
                            r: 1.4 + Math.random() * 1.4,
                            alpha: 0.88,
                            gloss: 0.55,
                            flowFactor: 1
                        });
                    }
                }
            }
        }

        function drawFluidBand(ctx) {
            if (!fluidHeights.length) return;
            const step = canvasWidth / (FLUID_SEGMENTS - 1 || 1);
            ctx.save();
            const baseY = POOL_OFFSET_TOP;
            
            // Draw smooth wobbly puddle band
            ctx.beginPath();
            ctx.moveTo(0, baseY + FLUID_BASE_HEIGHT);
            
            // Use quadratic curves for smoother appearance
            for (let i = 0; i < FLUID_SEGMENTS; i++) {
                const x = i * step;
                const y = baseY + FLUID_BASE_HEIGHT + clamp(fluidHeights[i], -6, 28);
                if (i === 0) {
                    ctx.lineTo(x, y);
                } else {
                    const prevX = (i - 1) * step;
                    const prevY = baseY + FLUID_BASE_HEIGHT + clamp(fluidHeights[i - 1], -6, 28);
                    const cpX = (prevX + x) / 2;
                    const cpY = (prevY + y) / 2;
                    ctx.quadraticCurveTo(prevX, prevY, cpX, cpY);
                }
            }
            
            // Close the shape
            ctx.lineTo(canvasWidth, baseY - 6);
            ctx.lineTo(0, baseY - 6);
            ctx.closePath();
            
            // Gradient for puddle appearance
            const grad = ctx.createLinearGradient(0, baseY - 4, 0, baseY + FLUID_BASE_HEIGHT + 20);
            grad.addColorStop(0, 'rgba(140, 215, 248, 0.15)');
            grad.addColorStop(0.4, 'rgba(110, 200, 245, 0.28)');
            grad.addColorStop(0.8, 'rgba(90, 185, 235, 0.35)');
            grad.addColorStop(1, 'rgba(75, 170, 225, 0.22)');
            ctx.fillStyle = grad;
            ctx.fill();
            
            // Subtle highlight line on top of puddle
            ctx.beginPath();
            ctx.moveTo(0, baseY + FLUID_BASE_HEIGHT + clamp(fluidHeights[0], -6, 28));
            for (let i = 1; i < FLUID_SEGMENTS; i++) {
                const x = i * step;
                const y = baseY + FLUID_BASE_HEIGHT + clamp(fluidHeights[i], -6, 28);
                const prevX = (i - 1) * step;
                const prevY = baseY + FLUID_BASE_HEIGHT + clamp(fluidHeights[i - 1], -6, 28);
                const cpX = (prevX + x) / 2;
                const cpY = (prevY + y) / 2;
                ctx.quadraticCurveTo(prevX, prevY, cpX, cpY);
            }
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.22)';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            ctx.restore();
        }

        function addToPuddles(x, amount) {
            addFluidMass(x, amount);
        }
        
        function render() {
            time = performance.now();
            const delta = Math.max(8, Math.min(34, time - lastTime || 16));
            lastTime = time;
            frameCount++;
            lightPhase = time * 0.001;
            
            condCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            shadowCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Track scroll speed for puddle sloshing
            const scrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            const rawScrollSpeed = (scrollY - lastScrollY) / Math.max(1, delta);
            scrollSpeed = scrollSpeed * 0.88 + rawScrollSpeed * 0.12; // Slightly more responsive
            lastScrollY = scrollY;

            // Cursor movement detection (for dwell vs pass behavior)
            const cursorDx = cursorX - lastCursorX;
            const cursorDy = cursorY - lastCursorY;
            const cursorSpeed = Math.sqrt(cursorDx * cursorDx + cursorDy * cursorDy);
            const cursorMoved = isHovering && cursorSpeed > 2;
            const cursorMovedFast = cursorSpeed > 8;
            
            recentWipeZones = recentWipeZones.filter(zone => (time - zone.t) < 3500);

            // Hover-time tinting (subtle glass warming effect)
            if (interactiveMode) {
                // Cursor always leaks a small amount of water while hovering
                if (isHovering && Math.random() < DRIP_CURSOR_LEAK) {
                    spawnDroplet(cursorX, cursorY, 0.9 + Math.random() * 0.3);
                }
                
                if (isHovering) {
                    hoverTime = Math.min(HOVER_FADE_RAMP, hoverTime + delta);
                } else {
                    hoverTime = Math.max(0, hoverTime - delta * (HOVER_FADE_RAMP / HOVER_FADE_DECAY));
                }
                const hoverProgress = Math.min(1, hoverTime / HOVER_FADE_RAMP);
                const hoverFade = Math.pow(hoverProgress, 0.6) * 0.20; // Max ~0.20
                header.style.setProperty('--hover-fade', hoverFade.toFixed(4));
            } else {
                header.style.setProperty('--hover-fade', '0');
            }
            
            // Update condensation spots
            for (let i = condensationSpots.length - 1; i >= 0; i--) {
                const spot = condensationSpots[i];
                let replacedThisFrame = false;
                
                // Fade in new spots
                if (spot.isNew && spot.fadeInProgress < 1) {
                    spot.fadeInProgress = Math.min(1, spot.fadeInProgress + NEW_CONDENSATION_RATE);
                    spot.currentOpacity = spot.targetOpacity * spot.fadeInProgress;
                    if (spot.fadeInProgress >= 1) spot.isNew = false;
                }
                
                // Wipe logic - LOCAL ONLY (only affects droplets within brush radius)
                if (interactiveMode && isHovering) {
                    const dx = spot.x - cursorX;
                    const dy = spot.y - cursorY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < WIPE_RADIUS) {
                        // Angular irregularity for organic brush shape
                        const angle = Math.atan2(dy, dx);
                        const irregularity = 1 + 0.14 * Math.cos(8 * angle) + 0.06 * Math.sin(5 * angle);
                        const localRadius = WIPE_RADIUS * irregularity;
                        
                        if (dist < localRadius) {
                            const oldWiped = spot.wipedAmount;
                            const distanceFalloff = 1 - (dist / localRadius);
                            
                            // Dwell vs pass behavior: dwelling wipes more, fast pass wipes less
                            const dwellBoost = cursorMovedFast ? WIPE_PASS_BOOST : (cursorMoved ? 1.15 : WIPE_DWELL_BOOST);
                            
                            // Calculate wipe amount but never remove 100%
                            const wipeAmount = WIPE_STRENGTH * (delta / 16) * (0.75 + distanceFalloff * 0.5) * dwellBoost;
                            spot.wipedAmount = Math.min(0.98, spot.wipedAmount + wipeAmount); // Cap at 0.98 for residue
                            spot.lastTouched = time;
                            
                            // Create shadow near cursor when wiping (local darkening)
                            if (spot.wipedAmount > oldWiped && Math.random() < 0.10 && dynamicShadows.length < MAX_SHADOWS) {
                                dynamicShadows.push(createDynamicShadow(cursorX, cursorY, Math.min(1, spot.wipedAmount + 0.1)));
                            }

                            // Spawn water droplets from wiped condensation
                            if (spot.wipedAmount > oldWiped && spot.wipedAmount > 0.4 && Math.random() < DRIP_SPAWN_CHANCE) {
                                spawnDroplet(spot.x, spot.y, Math.min(1.3, spot.wipedAmount + 0.35));
                                // Near heavy condensation, more water emission
                                if (spot.size > 12 && Math.random() < 0.3) {
                                    spawnDroplet(cursorX, cursorY, 1.0);
                                }
                            }

                            // Track wipe zone for regrowth bias
                            if (spot.wipedAmount > oldWiped && Math.random() < 0.18) {
                                recentWipeZones.push({ x: cursorX, y: cursorY, t: time });
                                if (recentWipeZones.length > MAX_RECENT_WIPES) {
                                    recentWipeZones.shift();
                                }
                            }
                        }
                    }
                }

                const distFromCursor = Math.sqrt(Math.pow(spot.x - cursorX, 2) + Math.pow(spot.y - cursorY, 2));
                // Gentle recovery and occasional respawn in a nearby ring
                if (!isHovering || distFromCursor > WIPE_RADIUS * 0.6) {
                    if (spot.wipedAmount > 0 && (time - spot.lastTouched) > WIPE_RECOVERY_HOLD) {
                        spot.wipedAmount = Math.max(0, spot.wipedAmount - WIPE_RECOVERY_RATE * delta);
                    }
                    if (spot.wipedAmount > 0.95 && (time - spot.lastTouched) > spot.regrowDelay) {
                        const ring = RESPREAD_MIN + Math.random() * (RESPREAD_MAX - RESPREAD_MIN);
                        const ringAngle = Math.random() * Math.PI * 2;
                        const baseX = spot.x + Math.cos(ringAngle) * ring;
                        const baseY = spot.y + Math.sin(ringAngle) * ring;
                        const replacement = createRandomSpot(baseX, baseY, 18 + Math.random() * 12);
                        condensationSpots[i] = replacement;
                        replacedThisFrame = true;
                    }
                }
                
                if (!replacedThisFrame) {
                    // Draw
                    const rippleVal = noise(spot.x, spot.y, time * RIPPLE_SPEED + spot.seed * 0.01);
                    drawCondensationSpot(condCtx, spot, rippleVal);
                }
            }
            
            // Spawn new condensation at random positions (simulating air moisture)
            if (interactiveMode && frameCount % 3 === 0 && Math.random() < NEW_CONDENSATION_CHANCE) {
                let newX = Math.random() * canvasWidth;
                let newY = Math.random() * canvasHeight;

                if (recentWipeZones.length && Math.random() < 0.7) {
                    const zone = recentWipeZones[Math.floor(Math.random() * recentWipeZones.length)];
                    const ang = Math.random() * Math.PI * 2;
                    const radius = WIPE_RADIUS * (1.2 + Math.random() * 1.1);
                    newX = clamp(zone.x + Math.cos(ang) * radius, 0, canvasWidth);
                    newY = clamp(zone.y + Math.sin(ang) * radius, 0, canvasHeight);
                } else if (isHovering) {
                    // Spawn slightly away from active wipe to avoid instant repetition
                    for (let attempts = 0; attempts < 5; attempts++) {
                        const candidateX = Math.random() * canvasWidth;
                        const candidateY = Math.random() * canvasHeight;
                        const distFromCursor = Math.sqrt(
                            Math.pow(candidateX - cursorX, 2) +
                            Math.pow(candidateY - cursorY, 2)
                        );
                        if (distFromCursor > WIPE_RADIUS * 1.5 && distFromCursor < WIPE_RADIUS * 3.2) {
                            newX = candidateX;
                            newY = candidateY;
                            break;
                        }
                    }
                }
                
                condensationSpots.push(createRandomSpot(newX, newY, 26));
                
                // Remove old spots to keep count manageable
                if (condensationSpots.length > SPOT_COUNT + 50) {
                    // Remove oldest fully-wiped spots first
                    const wipedIndex = condensationSpots.findIndex(s => s.wipedAmount > 0.95);
                    if (wipedIndex !== -1) {
                        condensationSpots.splice(wipedIndex, 1);
                    } else {
                        condensationSpots.shift();
                    }
                }
            }
            
            // Update and draw dynamic shadows
            for (let i = dynamicShadows.length - 1; i >= 0; i--) {
                const shadow = dynamicShadows[i];
                
                // Drift toward target
                shadow.x += (shadow.targetX - shadow.x) * 0.02;
                shadow.y += (shadow.targetY - shadow.y) * 0.02;
                
                // Fade based on lifetime
                const age = time - shadow.createdAt;
                if (age > shadow.lifetime) {
                    shadow.alpha -= 0.0065;
                }
                
                // Remove dead shadows
                if (shadow.alpha <= 0) {
                    dynamicShadows.splice(i, 1);
                    continue;
                }
                
                drawDynamicShadow(shadowCtx, shadow);
            }
            
            // Keep shadow count manageable (limit for performance)
            if (dynamicShadows.length > MAX_SHADOWS) {
                dynamicShadows.splice(0, dynamicShadows.length - MAX_SHADOWS);
            }

            // Water droplets (header glass surface with creep physics)
            if (interactiveMode) {
                for (let i = waterDroplets.length - 1; i >= 0; i--) {
                    const d = waterDroplets[i];
                    d.age += delta;
                    
                    // Stick phase: droplets cling before sliding
                    const isSticking = d.sticking && d.age < DRIP_STICK_DELAY;
                    const stickMod = isSticking ? 0.12 : 1;
                    
                    // Exit stick phase after delay
                    if (d.sticking && d.age >= DRIP_STICK_DELAY) {
                        d.sticking = false;
                    }
                    
                    // Gentle cursor influence (pushes droplets)
                    const dx = d.x - cursorX;
                    const dy = d.y - cursorY;
                    const dist2 = dx * dx + dy * dy;
                    if (isHovering && dist2 < (WIPE_RADIUS * WIPE_RADIUS * 0.6)) {
                        const dist = Math.sqrt(dist2) + 0.001;
                        const push = DRIP_PULL * (1 - dist / (WIPE_RADIUS * 0.75));
                        d.vx += (dx / dist) * push * -0.85;
                        d.vy += (dy / dist) * push * -0.35;
                    }
                    
                    // Physics: gravity (upward toward top edge), drift, friction
                    const sizeDrift = d.r * 0.0001 * stickMod; // Larger drops drift faster
                    d.vy += (DRIP_GRAVITY * delta + DRIP_FLOW * d.flowFactor + sizeDrift) * stickMod;
                    d.vx += DRIP_LATERAL * stickMod;
                    
                    // Scroll influence on glass droplets
                    d.vy += scrollSpeed * 0.45;
                    d.vx += scrollSpeed * 0.12 * Math.sin(d.x * 0.02);
                    
                    // High friction = slow creep
                    d.vx *= DRIP_FRICTION;
                    d.vy *= DRIP_FRICTION;
                    
                    // Apply movement
                    d.x += d.vx * delta * 0.88;
                    d.y += d.vy * delta * 0.88;
                    
                    // Slow alpha decay for visibility
                    d.alpha = Math.max(0.38, d.alpha * 0.9996);

                    // Reach top edge = contribute to puddle (crevice)
                    if (d.y <= POOL_OFFSET_TOP + d.r + 2) {
                        const impact = Math.min(1, Math.abs(d.vy) * 12);
                        addToPuddles(d.x, d.r * 1.1 + impact * 0.4);
                        spawnSplash(d.x, POOL_OFFSET_TOP + 2, impact * 0.7);
                        waterDroplets.splice(i, 1);
                        continue;
                    }
                    
                    // Reach bottom edge = SPILL onto page
                    if (d.y >= canvasHeight - d.r - 2) {
                        // Dispatch to page water system
                        const spillEvent = new CustomEvent('headerWaterSpill', {
                            detail: {
                                x: d.x,
                                y: canvasHeight,
                                vx: d.vx * 0.8,
                                vy: Math.max(0.035, d.vy * 0.6 + 0.02),
                                r: d.r * 1.05
                            }
                        });
                        window.dispatchEvent(spillEvent);
                        waterDroplets.splice(i, 1);
                        continue;
                    }
                    
                    // Out of bounds (sides only - can't exit top/bottom now)
                    if (d.x < -15 || d.x > canvasWidth + 15) {
                        waterDroplets.splice(i, 1);
                        continue;
                    }
                    
                    // Age/fade out
                    if (d.alpha < 0.08 || d.age > 3800) {
                        addToPuddles(d.x, d.r * 0.5);
                        waterDroplets.splice(i, 1);
                        continue;
                    }
                    
                    drawDroplet(condCtx, d);
                }

                // Splash particles
                for (let i = splashParticles.length - 1; i >= 0; i--) {
                    const p = splashParticles[i];
                    p.x += p.vx * delta * 0.85;
                    p.y += p.vy * delta * 0.85;
                    p.alpha *= SPLASH_DECAY;
                    p.r *= 0.988;
                    if (p.alpha < 0.015) {
                        splashParticles.splice(i, 1);
                        continue;
                    }
                    drawSplash(condCtx, p);
                }
                
                // Spill droplets (from fluid band overflow) - can fall onto page
                for (let i = spillDroplets.length - 1; i >= 0; i--) {
                    const d = spillDroplets[i];
                    // Stronger gravity for spill droplets (falling)
                    d.vy += 0.00055 * delta;
                    d.vx *= DRIP_FRICTION * 0.995;
                    d.vy *= DRIP_FRICTION * 0.998;
                    d.x += d.vx * delta * 0.9;
                    d.y += d.vy * delta * 0.9;
                    d.alpha = Math.max(0.28, d.alpha * 0.9993);
                    
                    // Reaches bottom of header - spill onto PAGE
                    if (d.y >= canvasHeight - 2) {
                        // Dispatch to page water system
                        const spillEvent = new CustomEvent('headerWaterSpill', {
                            detail: {
                                x: d.x,
                                y: canvasHeight,
                                vx: d.vx * 1.2,
                                vy: Math.max(0.04, d.vy * 0.8),
                                r: d.r * 1.1
                            }
                        });
                        window.dispatchEvent(spillEvent);
                        spillDroplets.splice(i, 1);
                        continue;
                    }
                    
                    // Hit sides or fade out
                    if (d.alpha < 0.05 || d.x < -20 || d.x > canvasWidth + 20) {
                        spillDroplets.splice(i, 1);
                        continue;
                    }
                    drawDroplet(condCtx, d);
                }
                
                // Update and draw puddle band
                updateFluid(delta);
                drawFluidBand(condCtx);
                
                // Reduce condensation brightness under thick puddle areas
                // (water absorbs mist effect)
                // This is handled implicitly by the alpha clamping in drawCondensationSpot
            }
            
            lastCursorX = cursorX;
            lastCursorY = cursorY;
            
            if (interactiveMode) {
                requestAnimationFrame(render);
            }
        }
        
        // --- Events ---
        function handleMouseMove(e) {
            const rect = header.getBoundingClientRect();
            cursorX = e.clientX - rect.left;
            cursorY = e.clientY - rect.top;
        }
        
        function handleMouseEnter(e) {
            isHovering = true;
            handleMouseMove(e);
        }
        
        function handleMouseLeave() {
            isHovering = false;
            cursorX = -1000;
            cursorY = -1000;
        }
        
        // --- Init ---
        resizeCanvases();
        render();
        
        if (interactiveMode) {
            header.addEventListener('mousemove', handleMouseMove, { passive: true });
            header.addEventListener('mouseenter', handleMouseEnter, { passive: true });
            header.addEventListener('mouseleave', handleMouseLeave, { passive: true });
        }
        
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvases();
                if (!interactiveMode) render();
            }, 150);
        }, { passive: true });
        
        if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
            header.removeEventListener('mousemove', handleMouseMove);
            header.removeEventListener('mouseenter', handleMouseEnter);
            header.removeEventListener('mouseleave', handleMouseLeave);
        }
    })();
    </script>
    <script>
    // ========================================
    // FULL-PAGE WATER PHYSICS SYSTEM
    // Features: Strong gravity, top barrier, glass-to-page spills,
    // cursor emission everywhere, droplet merging, pools, scroll motion
    // ========================================
    (function initFullPageWater() {
        const canvas = document.getElementById('pageWaterCanvas');
        const header = document.getElementById('header');
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const mediaHoverNone = window.matchMedia && window.matchMedia('(hover: none)').matches;
        const reducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const interactive = !(mediaHoverNone || reducedMotion);
        
        // === CONFIGURATION ===
        // Droplet limits (performance caps)
        const MAX_PAGE_DROPLETS = 70;       // Max page droplets
        const MAX_HEADER_DROPLETS = 25;     // Max header droplets (from glass)
        const MAX_POOLS = 4;                // Max pool regions
        const MAX_MERGE_CHECKS = 20;        // Limit merge comparisons per frame
        
        // Physics - STRONG GRAVITY (fix "space water" problem)
        const GRAVITY = 0.00085;            // Strong downward acceleration
        const FRICTION = 0.992;             // Moderate drag
        const GLASS_SLOPE_X = 0.00008;      // Slight lateral drift on glass
        const GLASS_SLOPE_Y = -0.00045;     // Upward drift toward top edge (glass tilt)
        const GLASS_STICK_TIME = 400;       // ms before droplets start sliding on glass
        const GLASS_FRICTION = 0.997;       // Higher friction on glass surface
        
        // Top barrier (prevents water from exiting upward)
        const TOP_BARRIER = 2;              // Barrier Y position
        const TOP_BOUNCE = 0.35;            // Bounce coefficient at barrier
        
        // Cursor emission
        const CURSOR_EMIT_RATE = 0.042;     // Chance per frame to emit from cursor
        const CURSOR_EMIT_RATE_HEADER = 0.068; // Higher rate when over header
        const CURSOR_SPRAY_SPEED = 0.08;    // Initial velocity from cursor movement
        
        // Cursor repulsion (magnetic push)
        const CURSOR_REPULSE_RADIUS = 120;
        const CURSOR_REPULSE_FORCE = 0.018;
        
        // Scroll influence
        const SCROLL_FORCE = 1.8;           // Force multiplier from scroll velocity
        const SCROLL_SLOSH_THRESHOLD = 0.15; // Min scroll speed to trigger slosh
        
        // Droplet merging
        const MERGE_DISTANCE = 8;           // Distance to trigger merge
        const MERGE_RADIUS_FACTOR = 0.7;    // How much radius combines (area-based)
        
        // Pools
        const POOL_ABSORB_RADIUS = 25;      // Radius around pool center to absorb droplets
        const POOL_MAX_VOLUME = 80;         // Max volume per pool
        const POOL_DECAY = 0.9998;          // Slow evaporation
        const POOL_SPAWN_Y = 0.85;          // Y position ratio for bottom pools
        
        // Visual
        const DROP_MIN_RADIUS = 2;
        const DROP_MAX_RADIUS = 6;
        const DROP_ALPHA_DECAY = 0.9997;
        
        // Header dimensions (will be updated)
        let headerHeight = 80;
        let headerBottom = 80;
        
        // === STATE ===
        let pageDroplets = [];
        let headerDroplets = [];  // Droplets on the glass (separate from page)
        let pools = [];
        let cw = window.innerWidth;
        let ch = window.innerHeight;
        let lastTime = performance.now();
        let cursorX = -1000;
        let cursorY = -1000;
        let lastCursorX = -1000;
        let lastCursorY = -1000;
        let cursorVx = 0;
        let cursorVy = 0;
        let isOverHeader = false;
        let lastScrollY = window.pageYOffset || 0;
        let scrollSpeed = 0;
        let lightPhase = 0;
        
        // === UTILITIES ===
        function clamp(v, min, max) {
            return Math.max(min, Math.min(max, v));
        }
        
        function distance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function resize() {
            cw = window.innerWidth;
            ch = window.innerHeight;
            canvas.width = cw;
            canvas.height = ch;
            canvas.style.width = cw + 'px';
            canvas.style.height = ch + 'px';
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            
            // Update header dimensions
            if (header) {
                const rect = header.getBoundingClientRect();
                headerHeight = rect.height;
                headerBottom = rect.bottom;
            }
            
            // Initialize pools at bottom of page
            initPools();
        }
        
        function initPools() {
            pools = [];
            const poolY = ch * POOL_SPAWN_Y;
            // Create a few pool regions across the bottom
            const poolSpacing = cw / (MAX_POOLS + 1);
            for (let i = 0; i < MAX_POOLS; i++) {
                pools.push({
                    x: poolSpacing * (i + 1) + (Math.random() - 0.5) * 40,
                    y: poolY + Math.random() * 30,
                    volume: 5 + Math.random() * 15,
                    targetVolume: 5 + Math.random() * 15,
                    wobble: Math.random() * Math.PI * 2
                });
            }
        }
        
        // === DROPLET CREATION ===
        function createDroplet(x, y, vx, vy, onGlass) {
            const radius = DROP_MIN_RADIUS + Math.random() * (DROP_MAX_RADIUS - DROP_MIN_RADIUS);
            return {
                x: x,
                y: y,
                vx: vx || 0,
                vy: vy || 0,
                r: radius,
                mass: radius * radius,  // Mass proportional to area
                alpha: 0.88 + Math.random() * 0.1,
                gloss: 0.4 + Math.random() * 0.35,
                age: 0,
                sticking: onGlass,
                onGlass: onGlass || false,
                stickStart: onGlass ? performance.now() : 0
            };
        }
        
        // Emit droplet from cursor
        function emitFromCursor(strength) {
            if (pageDroplets.length >= MAX_PAGE_DROPLETS) return;
            
            // Initial velocity based on cursor movement
            const vx = cursorVx * CURSOR_SPRAY_SPEED * strength + (Math.random() - 0.5) * 0.04;
            const vy = cursorVy * CURSOR_SPRAY_SPEED * strength + Math.random() * 0.02;
            
            const drop = createDroplet(cursorX, cursorY, vx, vy, isOverHeader);
            
            if (isOverHeader) {
                headerDroplets.push(drop);
            } else {
                pageDroplets.push(drop);
            }
        }
        
        // Spill droplet from header onto page (glass-to-page transition)
        function spillFromHeader(drop) {
            // Convert header droplet to page droplet
            drop.onGlass = false;
            drop.sticking = false;
            // Give it some downward velocity
            drop.vy = Math.max(0.08, drop.vy + 0.05);
            pageDroplets.push(drop);
        }
        
        // === DROPLET MERGING ===
        function mergeDroplets(arr) {
            let checks = 0;
            for (let i = arr.length - 1; i >= 1 && checks < MAX_MERGE_CHECKS; i--) {
                const a = arr[i];
                for (let j = i - 1; j >= 0 && checks < MAX_MERGE_CHECKS; j--) {
                    const b = arr[j];
                    checks++;
                    
                    const d = distance(a.x, a.y, b.x, b.y);
                    const minDist = (a.r + b.r) * 0.6;
                    
                    if (d < minDist + MERGE_DISTANCE) {
                        // Merge a into b
                        const totalMass = a.mass + b.mass;
                        
                        // Position: weighted average
                        b.x = (a.x * a.mass + b.x * b.mass) / totalMass;
                        b.y = (a.y * a.mass + b.y * b.mass) / totalMass;
                        
                        // Velocity: momentum conservation
                        b.vx = (a.vx * a.mass + b.vx * b.mass) / totalMass;
                        b.vy = (a.vy * a.mass + b.vy * b.mass) / totalMass;
                        
                        // Radius: area-based combination
                        const newArea = a.r * a.r + b.r * b.r;
                        b.r = Math.min(DROP_MAX_RADIUS * 1.5, Math.sqrt(newArea) * MERGE_RADIUS_FACTOR);
                        b.mass = b.r * b.r;
                        
                        // Preserve higher alpha
                        b.alpha = Math.max(a.alpha, b.alpha);
                        
                        // Remove merged droplet
                        arr.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        // === POOL INTERACTION ===
        function checkPoolAbsorption(drop, pools) {
            for (const pool of pools) {
                const d = distance(drop.x, drop.y, pool.x, pool.y);
                if (d < POOL_ABSORB_RADIUS + pool.volume * 0.2) {
                    // Absorb into pool
                    pool.targetVolume = Math.min(POOL_MAX_VOLUME, pool.targetVolume + drop.r * 0.8);
                    pool.wobble += 0.3; // Ripple effect
                    return true;
                }
            }
            return false;
        }
        
        // === PHYSICS UPDATE ===
        function updateDroplet(drop, dt, isHeaderDrop) {
            drop.age += dt;
            
            const now = performance.now();
            
            // Cursor repulsion
            const dx = drop.x - cursorX;
            const dy = drop.y - cursorY;
            const dist2 = dx * dx + dy * dy;
            
            if (dist2 < CURSOR_REPULSE_RADIUS * CURSOR_REPULSE_RADIUS && dist2 > 1) {
                const dist = Math.sqrt(dist2);
                const force = CURSOR_REPULSE_FORCE * (1 - dist / CURSOR_REPULSE_RADIUS);
                drop.vx += (dx / dist) * force;
                drop.vy += (dy / dist) * force;
            }
            
            if (isHeaderDrop && drop.onGlass) {
                // Glass physics: stick phase, then creep toward crevice
                const isSticking = drop.sticking && (now - drop.stickStart) < GLASS_STICK_TIME;
                
                if (isSticking) {
                    // Almost no movement during stick phase
                    drop.vx *= 0.5;
                    drop.vy *= 0.5;
                } else {
                    drop.sticking = false;
                    
                    // Glass tilt: drift toward top edge (crevice)
                    drop.vx += GLASS_SLOPE_X * dt;
                    drop.vy += GLASS_SLOPE_Y * dt * (1 + drop.r * 0.02);
                    
                    // Higher friction on glass
                    drop.vx *= GLASS_FRICTION;
                    drop.vy *= GLASS_FRICTION;
                }
                
                // Scroll influence on glass droplets
                drop.vy += scrollSpeed * SCROLL_FORCE * 0.4;
                drop.vx += scrollSpeed * SCROLL_FORCE * 0.15 * Math.sin(drop.x * 0.01);
                
            } else {
                // Page physics: strong gravity
                drop.vy += GRAVITY * dt;
                
                // Scroll influence
                drop.vy += scrollSpeed * SCROLL_FORCE * 0.8;
                
                // Normal friction
                drop.vx *= FRICTION;
                drop.vy *= FRICTION;
            }
            
            // Apply velocity
            drop.x += drop.vx * dt * 0.9;
            drop.y += drop.vy * dt * 0.9;
            
            // Top barrier (prevent upward exit)
            if (drop.y < TOP_BARRIER) {
                drop.y = TOP_BARRIER;
                drop.vy = Math.abs(drop.vy) * TOP_BOUNCE;
                // Slide along barrier
                drop.vx += (Math.random() - 0.5) * 0.02;
            }
            
            // Alpha decay
            drop.alpha *= DROP_ALPHA_DECAY;
        }
        
        // === DRAWING ===
        function drawDroplet(drop) {
            if (drop.alpha < 0.05) return;
            
            ctx.save();
            ctx.translate(drop.x, drop.y);
            
            // Time-varying light glint
            const glint = 0.6 + 0.35 * Math.sin(lightPhase + drop.x * 0.004);
            
            // Main droplet gradient - aqua/cyan water color
            const grad = ctx.createRadialGradient(
                -drop.r * 0.25, -drop.r * 0.25, 0,
                0, 0, drop.r * 1.4
            );
            grad.addColorStop(0, `rgba(255, 255, 255, ${drop.alpha * 0.4})`);
            grad.addColorStop(0.3, `rgba(180, 235, 255, ${drop.alpha * 0.62})`);
            grad.addColorStop(0.55, `rgba(120, 210, 250, ${drop.alpha * 0.45})`);
            grad.addColorStop(0.8, `rgba(85, 190, 240, ${drop.alpha * 0.22})`);
            grad.addColorStop(1, `rgba(70, 170, 225, 0)`);
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            // Slightly elongated for teardrop effect
            ctx.ellipse(0, 0, drop.r * 1.1, drop.r * 1.35, -0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Specular highlight
            ctx.beginPath();
            ctx.arc(-drop.r * 0.2, -drop.r * 0.3, drop.r * 0.32, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${drop.alpha * drop.gloss * 0.5 * glint})`;
            ctx.fill();
            
            // Secondary highlight for larger drops
            if (drop.r > 3.5) {
                ctx.beginPath();
                ctx.arc(drop.r * 0.12, drop.r * 0.18, drop.r * 0.16, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${drop.alpha * 0.18 * glint})`;
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        function drawPool(pool) {
            if (pool.volume < 1) return;
            
            ctx.save();
            ctx.translate(pool.x, pool.y);
            
            // Pool wobble animation
            const wobbleX = Math.sin(pool.wobble) * 0.08;
            const wobbleY = Math.cos(pool.wobble * 1.3) * 0.04;
            
            const baseRadius = 15 + pool.volume * 0.6;
            const rx = baseRadius * (1 + wobbleX);
            const ry = baseRadius * 0.5 * (1 + wobbleY);
            
            // Pool gradient - matches droplet colors
            const grad = ctx.createRadialGradient(
                -rx * 0.15, -ry * 0.2, 0,
                0, 0, rx
            );
            grad.addColorStop(0, `rgba(140, 220, 255, 0.35)`);
            grad.addColorStop(0.4, `rgba(100, 200, 250, 0.28)`);
            grad.addColorStop(0.7, `rgba(80, 185, 240, 0.18)`);
            grad.addColorStop(1, `rgba(65, 165, 225, 0)`);
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight rim
            ctx.strokeStyle = `rgba(255, 255, 255, 0.22)`;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.ellipse(0, -ry * 0.15, rx * 0.85, ry * 0.7, 0, Math.PI * 0.1, Math.PI * 0.9);
            ctx.stroke();
            
            ctx.restore();
        }
        
        // === MAIN RENDER LOOP ===
        function render() {
            const now = performance.now();
            let dt = now - lastTime;
            
            // Skip frame if too fast (throttle to ~40fps for performance)
            if (dt < 24) {
                requestAnimationFrame(render);
                return;
            }
            
            dt = Math.min(40, dt);
            lastTime = now;
            lightPhase = now * 0.0012;
            
            // Track scroll speed
            const scrollY = window.pageYOffset || document.documentElement.scrollTop || 0;
            const rawScrollSpeed = (scrollY - lastScrollY) / Math.max(1, dt);
            scrollSpeed = scrollSpeed * 0.88 + rawScrollSpeed * 0.12;
            lastScrollY = scrollY;
            
            // Track cursor velocity
            const cursorDx = cursorX - lastCursorX;
            const cursorDy = cursorY - lastCursorY;
            cursorVx = cursorVx * 0.7 + cursorDx * 0.3;
            cursorVy = cursorVy * 0.7 + cursorDy * 0.3;
            lastCursorX = cursorX;
            lastCursorY = cursorY;
            
            // Check if cursor is over header
            if (header) {
                const rect = header.getBoundingClientRect();
                isOverHeader = cursorY >= rect.top && cursorY <= rect.bottom &&
                               cursorX >= rect.left && cursorX <= rect.right;
                headerBottom = rect.bottom;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, cw, ch);
            
            // === CURSOR EMISSION ===
            if (cursorX > -500) {
                const emitRate = isOverHeader ? CURSOR_EMIT_RATE_HEADER : CURSOR_EMIT_RATE;
                if (Math.random() < emitRate) {
                    emitFromCursor(0.8 + Math.random() * 0.4);
                }
            }
            
            // === UPDATE HEADER DROPLETS (on glass) ===
            for (let i = headerDroplets.length - 1; i >= 0; i--) {
                const drop = headerDroplets[i];
                updateDroplet(drop, dt, true);
                
                // Check if droplet spills off glass (passes header bottom)
                if (drop.y > headerBottom + 5) {
                    headerDroplets.splice(i, 1);
                    spillFromHeader(drop);
                    continue;
                }
                
                // Check if droplet reaches top crevice (absorbed into header fluid band)
                if (drop.y < TOP_BARRIER + 8) {
                    // Let the header's own fluid system handle this
                    headerDroplets.splice(i, 1);
                    continue;
                }
                
                // Remove faded droplets
                if (drop.alpha < 0.06 || drop.x < -20 || drop.x > cw + 20) {
                    headerDroplets.splice(i, 1);
                    continue;
                }
                
                drawDroplet(drop);
            }
            
            // Cap header droplets
            while (headerDroplets.length > MAX_HEADER_DROPLETS) {
                headerDroplets.shift();
            }
            
            // === UPDATE PAGE DROPLETS ===
            for (let i = pageDroplets.length - 1; i >= 0; i--) {
                const drop = pageDroplets[i];
                updateDroplet(drop, dt, false);
                
                // Check pool absorption
                if (checkPoolAbsorption(drop, pools)) {
                    pageDroplets.splice(i, 1);
                    continue;
                }
                
                // Remove out of bounds or faded
                if (drop.y > ch + 30 || drop.x < -30 || drop.x > cw + 30 || drop.alpha < 0.05) {
                    pageDroplets.splice(i, 1);
                    continue;
                }
                
                drawDroplet(drop);
            }
            
            // Merge page droplets
            mergeDroplets(pageDroplets);
            
            // Cap page droplets
            while (pageDroplets.length > MAX_PAGE_DROPLETS) {
                pageDroplets.shift();
            }
            
            // === UPDATE POOLS ===
            for (const pool of pools) {
                // Animate toward target volume
                pool.volume += (pool.targetVolume - pool.volume) * 0.04;
                
                // Slow decay (evaporation)
                pool.targetVolume *= POOL_DECAY;
                pool.targetVolume = Math.max(2, pool.targetVolume);
                
                // Wobble animation decay
                pool.wobble *= 0.985;
                pool.wobble += 0.008;
                
                // Scroll-induced wobble
                if (Math.abs(scrollSpeed) > SCROLL_SLOSH_THRESHOLD) {
                    pool.wobble += scrollSpeed * 0.15;
                }
                
                drawPool(pool);
            }
            
            // === SCROLL-TRIGGERED SPILLS ===
            // Fast scroll can cause water to spill from header crevice to page
            if (Math.abs(scrollSpeed) > 0.35 && headerDroplets.length < MAX_HEADER_DROPLETS * 0.5) {
                if (Math.random() < Math.abs(scrollSpeed) * 0.08) {
                    // Spawn a droplet that will immediately spill
                    const spillX = Math.random() * cw;
                    const spill = createDroplet(spillX, headerBottom - 5, (Math.random() - 0.5) * 0.05, 0.06, false);
                    pageDroplets.push(spill);
                }
            }
            
            requestAnimationFrame(render);
        }
        
        // === EVENT HANDLERS ===
        function handleMouseMove(e) {
            cursorX = e.clientX;
            cursorY = e.clientY;
        }
        
        // === HEADER SPILL EVENT HANDLER ===
        // Listen for water spills from header crevice
        function handleHeaderSpill(e) {
            if (!interactive) return;
            if (pageDroplets.length >= MAX_PAGE_DROPLETS) return;
            
            const d = e.detail;
            if (!d) return;
            
            // Get header position to convert coordinates
            const headerRect = header ? header.getBoundingClientRect() : { bottom: 80 };
            
            pageDroplets.push({
                x: d.x,
                y: headerRect.bottom + 2, // Start just below header
                vx: d.vx || (Math.random() - 0.5) * 0.03,
                vy: d.vy || 0.05,
                r: d.r || 2.5 + Math.random() * 2,
                mass: (d.r || 3) * (d.r || 3),
                alpha: 0.9,
                gloss: 0.45 + Math.random() * 0.25,
                age: 0,
                sticking: false,
                onGlass: false,
                stickStart: 0
            });
        }
        
        // === INITIALIZATION ===
        if (interactive) {
            resize();
            window.addEventListener('resize', resize, { passive: true });
            document.addEventListener('mousemove', handleMouseMove, { passive: true });
            window.addEventListener('headerWaterSpill', handleHeaderSpill);
            
            // Start render loop
            render();
        } else {
            // Non-interactive: just show static pools
            resize();
            for (const pool of pools) {
                pool.volume = pool.targetVolume;
                drawPool(pool);
            }
        }
    })();
    </script>
</body>
</html>
